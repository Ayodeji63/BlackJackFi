{"version":3,"file":"static/js/498.b238794e.chunk.js","mappings":"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","sources":["../node_modules/.pnpm/@ethersproject+base64@5.7.0/node_modules/@ethersproject/base64/src.ts/browser-base64.ts","../node_modules/.pnpm/@ethersproject+networks@5.7.1/node_modules/@ethersproject/networks/src.ts/_version.ts","../node_modules/.pnpm/@ethersproject+networks@5.7.1/node_modules/@ethersproject/networks/src.ts/index.ts","../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/src.ts/_version.ts","../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/src.ts/ens-normalize/decoder.ts","../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/src.ts/ens-normalize/lib.ts","../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/src.ts/ens-normalize/include.ts","../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/src.ts/namehash.ts","../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/src.ts/addresses.ts","../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/src.ts/formatter.ts","../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/src.ts/base-provider.ts","../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/src.ts/hashes.ts","../node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts","../node_modules/.pnpm/@ethersproject+web@5.7.1/node_modules/@ethersproject/web/src.ts/browser-geturl.ts","../node_modules/.pnpm/@ethersproject+web@5.7.1/node_modules/@ethersproject/web/src.ts/index.ts","../node_modules/.pnpm/@ethersproject+web@5.7.1/node_modules/@ethersproject/web/src.ts/_version.ts","../node_modules/.pnpm/alchemy-sdk@3.1.2/node_modules/alchemy-sdk/src/internal/request-batcher.ts","../node_modules/.pnpm/alchemy-sdk@3.1.2/node_modules/alchemy-sdk/src/api/alchemy-provider.ts","../node_modules/.pnpm/bech32@1.1.4/node_modules/bech32/index.js"],"sourcesContent":["\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function decode(textData: string): Uint8Array {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\n\nexport function encode(data: BytesLike): string {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n\n\n","export const version = \"networks/5.7.1\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Network, Networkish } from \"./types\";\n\nexport {\n    Network,\n    Networkish\n};\n\ntype DefaultProviderFunc = (providers: any, options?: any) => any;\n\ninterface Renetworkable extends DefaultProviderFunc {\n    renetwork: (network: Network) => DefaultProviderFunc;\n};\n\nfunction isRenetworkable(value: any): value is Renetworkable {\n    return (value && typeof(value.renetwork) === \"function\");\n}\n\nfunction ethDefaultProvider(network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (options == null) { options = { }; }\n        const providerList: Array<any> = [];\n\n        if (providers.InfuraProvider && options.infura !== \"-\") {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            } catch(error) { }\n        }\n\n        if (providers.EtherscanProvider && options.etherscan !== \"-\") {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            } catch(error) { }\n        }\n\n        if (providers.AlchemyProvider && options.alchemy !== \"-\") {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            } catch(error) { }\n        }\n\n        if (providers.PocketProvider && options.pocket !== \"-\") {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [ \"goerli\", \"ropsten\", \"rinkeby\", \"sepolia\" ];\n            try {\n                const provider = new providers.PocketProvider(network, options.pocket);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch(error) { }\n        }\n\n        if (providers.CloudflareProvider && options.cloudflare !== \"-\") {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            } catch(error) { }\n        }\n\n        if (providers.AnkrProvider && options.ankr !== \"-\") {\n            try {\n                const skip = [ \"ropsten\" ];\n                const provider = new providers.AnkrProvider(network, options.ankr);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch(error) { }\n        }\n\n        if (providerList.length === 0) { return null; }\n\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            } else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n\n        return providerList[0];\n    };\n\n    func.renetwork = function(network: Network) {\n        return ethDefaultProvider(network);\n    };\n\n    return func;\n}\n\nfunction etcDefaultProvider(url: string, network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n\n        return null;\n    };\n\n    func.renetwork = function(network: Network) {\n        return etcDefaultProvider(url, network);\n    };\n\n    return func;\n}\n\nconst homestead: Network = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\n\nconst ropsten: Network = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\n\nconst classicMordor: Network = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n\n// See: https://chainlist.org\nconst networks: { [name: string]: Network } = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n\n    homestead: homestead,\n    mainnet: homestead,\n\n    morden: { chainId: 2, name: \"morden\" },\n\n    ropsten: ropsten,\n    testnet: ropsten,\n\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n\n    sepolia: {\n        chainId: 11155111,\n        name: \"sepolia\",\n        _defaultProvider: ethDefaultProvider(\"sepolia\")\n    },\n\n\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n\n    xdai: { chainId: 100, name: \"xdai\" },\n\n    matic: {\n        chainId: 137,\n        name: \"matic\",\n        _defaultProvider: ethDefaultProvider(\"matic\")\n    },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n\n    optimism: {\n        chainId: 10,\n        name: \"optimism\",\n        _defaultProvider: ethDefaultProvider(\"optimism\")\n    },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n    \"arbitrum-goerli\": { chainId: 421613, name: \"arbitrum-goerli\" },\n\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n}\n\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nexport function getNetwork(network: Networkish): Network {\n    // No network (null)\n    if (network == null) { return null; }\n\n    if (typeof(network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n\n    if (typeof(network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) { return null; }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n\n    const standard  = networks[network.name];\n\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof(network.chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider: DefaultProviderFunc = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        } else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n","export const version = \"providers/5.7.2\";\n","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\nexport type Numbers = Uint8Array | Array<number>;\nexport type NextFunc = (...args: Array<any>) => number;\n\n// https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js\nfunction flat(array: Array<any>, depth?: number): Array<any> {\n    if (depth == null) { depth = 1; }\n    const result: Array<any> = [];\n\n    const forEach = result.forEach;\n\n    const flatDeep = function (arr: Array<any>, depth: number) {\n        forEach.call(arr, function (val: any) {\n            if (depth > 0 && Array.isArray(val)) {\n                flatDeep(val, depth - 1);\n            } else {\n               result.push(val);\n            }\n        });\n    };\n\n    flatDeep(array, depth);\n    return result;\n}\n\nfunction fromEntries<T extends string | number | symbol = string | number | symbol, U = any>(array: Array<[T, U]>): Record<T, U> {\n    const result: Record<T, U> = <Record<T, U>>{ };\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        result[value[0]] = value[1];\n    }\n    return result;\n}\n\nexport function decode_arithmetic(bytes: Numbers): Array<number> {\n\tlet pos = 0;\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\n\t\n\t// decode the frequency table\n\tlet symbol_count = u16();\n\tlet total = 1;\n\tlet acc = [0, 1]; // first symbol has frequency 1\n\tfor (let i = 1; i < symbol_count; i++) {\n\t\tacc.push(total += u16());\n\t}\n\n\t// skip the sized-payload that the last 3 symbols index into\n\tlet skip = u16();\n\tlet pos_payload = pos;\n\tpos += skip;\n\n\tlet read_width = 0;\n\tlet read_buffer = 0; \n\tfunction read_bit() {\n\t\tif (read_width == 0) {\n\t\t\t// this will read beyond end of buffer\n\t\t\t// but (undefined|0) => zero pad\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\n\t\t\tread_width = 8;\n\t\t}\n\t\treturn (read_buffer >> --read_width) & 1;\n\t}\n\n\tconst N = 31;\n\tconst FULL = 2**N;\n\tconst HALF = FULL >>> 1;\n\tconst QRTR = HALF >> 1;\n\tconst MASK = FULL - 1;\n\n\t// fill register\n\tlet register = 0;\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\n\n\tlet symbols = [];\n\tlet low = 0;\n\tlet range = FULL; // treat like a float\n\twhile (true) {\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\n\t\tlet start = 0;\n\t\tlet end = symbol_count;\n\t\twhile (end - start > 1) { // binary search\n\t\t\tlet mid = (start + end) >>> 1;\n\t\t\tif (value < acc[mid]) {\n\t\t\t\tend = mid;\n\t\t\t} else {\n\t\t\t\tstart = mid;\n\t\t\t}\n\t\t}\n\t\tif (start == 0) break; // first symbol is end mark\n\t\tsymbols.push(start);\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1\n\t\twhile (((a ^ b) & HALF) == 0) {\n\t\t\tregister = (register << 1) & MASK | read_bit();\n\t\t\ta = (a << 1) & MASK;\n\t\t\tb = (b << 1) & MASK | 1;\n\t\t}\n\t\twhile (a & ~b & QRTR) {\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\n\t\t\ta = (a << 1) ^ HALF;\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\n\t\t}\n\t\tlow = a;\n\t\trange = 1 + b - a;\n\t}\n\tlet offset = symbol_count - 4;\n\treturn symbols.map(x => { // index into payload\n\t\tswitch (x - offset) {\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n\t\t\tcase 1: return offset + bytes[pos_payload++];\n\t\t\tdefault: return x - 1;\n\t\t}\n\t});\n}\t\n\n\n// returns an iterator which returns the next symbol\nexport function read_payload(v: Numbers): NextFunc {\n\tlet pos = 0;\n\treturn () => v[pos++];\n}\nexport function read_compressed_payload(bytes: Numbers): NextFunc {\n\treturn read_payload(decode_arithmetic(bytes));\n}\n\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nexport function signed(i: number): number { \n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\n}\n\nfunction read_counts(n: number, next: NextFunc): Array<number> {\n\tlet v = Array(n);\n\tfor (let i = 0; i < n; i++) v[i] = 1 + next();\n\treturn v;\n}\n\nfunction read_ascending(n: number, next: NextFunc): Array<number> {\n\tlet v = Array(n);\n\tfor (let i = 0, x = -1; i < n; i++) v[i] = x += 1 + next();\n\treturn v;\n}\n\nfunction read_deltas(n: number, next: NextFunc): Array<number> {\n\tlet v = Array(n);\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\n\treturn v;\n}\n\nexport function read_member_array(next: NextFunc, lookup?: Record<number, number>) {\n    let v = read_ascending(next(), next);\n    let n = next();\n    let vX = read_ascending(n, next);\n    let vN = read_counts(n, next);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < vN[i]; j++) {\n            v.push(vX[i] + j);\n        }\n    }\n    return lookup ? v.map(x => lookup[x]) : v;\n}\n\n// returns array of \n// [x, ys] => single replacement rule\n// [x, ys, n, dx, dx] => linear map\nexport function read_mapped_map(next: NextFunc): Record<number, Array<number>> {\n\tlet ret = [];\n\twhile (true) {\n\t\tlet w = next();\n\t\tif (w == 0) break;\n\t\tret.push(read_linear_table(w, next));\n\t}\n\twhile (true) {\n\t\tlet w = next() - 1;\n\t\tif (w < 0) break;\n\t\tret.push(read_replacement_table(w, next));\n\t}\n\treturn fromEntries<number, Array<number>>(flat(ret));\n}\n\nexport function read_zero_terminated_array(next: NextFunc): Array<number> {\n\tlet v = [];\n\twhile (true) {\n\t\tlet i = next();\n\t\tif (i == 0) break;\n\t\tv.push(i);\n\t}\n\treturn v;\n}\n\nfunction read_transposed(n: number, w: number, next: NextFunc): Array<Array<number>> {\n    let m = Array(n).fill(undefined).map(() => []);\n    for (let i = 0; i < w; i++) {\n        read_deltas(n, next).forEach((x, j) => m[j].push(x));\n    }\n    return m;\n}\n\n\nfunction read_linear_table(w: number, next: NextFunc): Array<Array<number | Array<number>>> {\n\tlet dx = 1 + next();\n\tlet dy = next();\n\tlet vN = read_zero_terminated_array(next);\n\tlet m = read_transposed(vN.length, 1+w, next);\n\treturn flat(m.map((v, i) => {\n\t  const x = v[0], ys = v.slice(1);\n\t\t//let [x, ...ys] = v;\n\t\t//return Array(vN[i]).fill().map((_, j) => {\n\t\treturn Array(vN[i]).fill(undefined).map((_, j) => {\n\t\t\tlet j_dy = j * dy;\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\n\t\t});\n\t}));\n}\n\nfunction read_replacement_table(w: number, next: NextFunc): Array<[ number, Array<number> ]> {\n\tlet n = 1 + next();\n\tlet m = read_transposed(n, 1+w, next);\n\treturn m.map(v => [v[0], v.slice(1)]);\n}\n\nexport type Branch = {\n    set: Set<number>;\n    node: Node;\n};\n\nexport type Node = {\n    branches: Array<Branch>;\n    valid: number;\n    fe0f: boolean;\n    save: boolean;\n    check: boolean;\n};\n\nexport function read_emoji_trie(next: NextFunc): Node {\n\tlet sorted = read_member_array(next).sort((a, b) => a - b);\n\treturn read();\n\tfunction read(): Node {\n\t\tlet branches = [];\n\t\twhile (true) {\n\t\t\tlet keys = read_member_array(next, sorted);\n\t\t\tif (keys.length == 0) break;\n\t\t\tbranches.push({set: new Set(keys), node: read()});\n\t\t}\n    branches.sort((a, b) => b.set.size - a.set.size); // sort by likelihood\n \t\tlet temp = next();\n \t\tlet valid = temp % 3;\n \t\ttemp = (temp / 3)|0;\n \t\tlet fe0f = !!(temp & 1);\n \t\ttemp >>= 1;\n \t\tlet save = temp == 1;\n \t\tlet check = temp == 2;\n \t\treturn {branches, valid, fe0f, save, check};\n\t}\n}\n","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\nimport { toUtf8CodePoints } from \"@ethersproject/strings\";\n\nimport { getData } from './include.js';\nconst r = getData();\n\nimport {read_member_array, read_mapped_map, read_emoji_trie} from './decoder.js';\n\n// @TODO: This should be lazily loaded\n\nconst VALID = new Set(read_member_array(r));\nconst IGNORED = new Set(read_member_array(r));\nconst MAPPED = read_mapped_map(r);\nconst EMOJI_ROOT = read_emoji_trie(r);\n//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));\n\n//const STOP = 0x2E;\nconst HYPHEN = 0x2D;\nconst UNDERSCORE = 0x5F;\n\nfunction explode_cp(name: string): Array<number> {\n    return toUtf8CodePoints(name);\n}\n\nfunction filter_fe0f(cps: Array<number>): Array<number> {\n    return cps.filter(cp => cp != 0xFE0F);\n}\n\nexport function ens_normalize_post_check(name: string): string {\n\tfor (let label of name.split('.')) {\n\t\tlet cps = explode_cp(label);\n\t\ttry {\n\t\t\tfor (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {\n\t\t\t\tif (cps[i] !== UNDERSCORE) {\n\t\t\t\t\tthrow new Error(`underscore only allowed at start`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cps.length >= 4 && cps.every(cp => cp < 0x80) && cps[2] === HYPHEN && cps[3] === HYPHEN) {\n\t\t\t\tthrow new Error(`invalid label extension`);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthrow new Error(`Invalid label \"${label}\": ${err.message}`);\n\t\t}\n\t}\n\treturn name;\n}\n\nexport function ens_normalize(name: string): string {\n\treturn ens_normalize_post_check(normalize(name, filter_fe0f));\n}\n\nfunction normalize(name: string, emoji_filter: (a: Array<number>) => Array<number>): string {\n\tlet input = explode_cp(name).reverse(); // flip for pop\n\tlet output = [];\n\twhile (input.length) {\t\t\n\t\tlet emoji = consume_emoji_reversed(input);\n\t\tif (emoji) {\n\t\t\toutput.push(...emoji_filter(emoji));\n\t\t\tcontinue;\n\t\t}\n\t\tlet cp = input.pop();\n\t\tif (VALID.has(cp)) {\n\t\t\toutput.push(cp);\n\t\t\tcontinue;\n\t\t} \n\t\tif (IGNORED.has(cp)) {\n\t\t\tcontinue;\n\t\t}\n\t\tlet cps = MAPPED[cp];\n\t\tif (cps) {\n\t\t\toutput.push(...cps);\n\t\t\tcontinue;\n\t\t}\n\t\tthrow new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);\n\t}\n\treturn ens_normalize_post_check(nfc(String.fromCodePoint(...output)));\n}\n\nfunction nfc(s: string): string {\n    return s.normalize('NFC');\n}\n\nfunction consume_emoji_reversed(cps: Array<number>, eaten?: Array<number>) {\n\tlet node = EMOJI_ROOT;\n\tlet emoji;\n\tlet saved;\n\tlet stack = [];\n\tlet pos = cps.length;\n\tif (eaten) eaten.length = 0; // clear input buffer (if needed)\n\twhile (pos) {\n\t\tlet cp = cps[--pos];\n\t\tnode = node.branches.find(x => x.set.has(cp))?.node;\n\t\tif (!node) break;\n\t\tif (node.save) { // remember\n\t\t\tsaved = cp;\n\t\t} else if (node.check) { // check exclusion\n\t\t\tif (cp === saved) break;\n\t\t}\n\t\tstack.push(cp);\n\t\tif (node.fe0f) {\n\t\t\tstack.push(0xFE0F);\n\t\t\tif (pos > 0 && cps[pos - 1] == 0xFE0F) pos--; // consume optional FE0F\n\t\t}\n\t\tif (node.valid) { // this is a valid emoji (so far)\n\t\t\temoji = stack.slice(); // copy stack\n\t\t\tif (node.valid == 2) emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\n\t\t\tcps.length = pos; // truncate\n\t\t}\n\t}\n\treturn emoji;\n}\n","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\nimport { decode } from \"@ethersproject/base64\";\n\nimport {read_compressed_payload} from './decoder.js';\n\nexport function getData(): () => number {\n    return read_compressed_payload(decode('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'));\n}\n\n","import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { ens_normalize } from \"./ens-normalize/lib\";\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\n\nfunction checkComponent(comp: Uint8Array): Uint8Array {\n    if (comp.length === 0) { throw new Error(\"invalid ENS name; empty component\"); }\n    return comp;\n}\n\nfunction ensNameSplit(name: string): Array<Uint8Array> {\n    const bytes = toUtf8Bytes(ens_normalize(name));\n    const comps: Array<Uint8Array> = [ ];\n\n    if (name.length === 0) { return comps; }\n\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n\n    // There was a stray separator at the end of the name\n    if (last >= bytes.length) { throw new Error(\"invalid ENS name; empty component\"); }\n\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\n\nexport function ensNormalize(name: string): string {\n    return ensNameSplit(name).map((comp) => toUtf8String(comp)).join(\".\");\n}\n\nexport function isValidName(name: string): boolean {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    } catch (error) { }\n    return false;\n}\n\nexport function namehash(name: string): string {\n    /* istanbul ignore if */\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n\n    let result: string | Uint8Array = Zeros;\n\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = keccak256(concat([result, keccak256(comps.pop())]));\n    }\n\n    return hexlify(result);\n}\n\nexport function dnsEncode(name: string): string {\n    return hexlify(concat(ensNameSplit(name).map((comp) => {\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n\n    }))) + \"00\";\n}\n","export const AddressZero = \"0x0000000000000000000000000000000000000000\";\n\n","\"use strict\";\n\nimport { Block, TransactionReceipt, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport type FormatFunc = (value: any) => any;\n\nexport type FormatFuncs = { [ key: string ]: FormatFunc };\n\nexport type Formats = {\n    transaction: FormatFuncs,\n    transactionRequest: FormatFuncs,\n    receipt: FormatFuncs,\n    receiptLog: FormatFuncs,\n    block: FormatFuncs,\n    blockWithTransactions: FormatFuncs,\n    filter: FormatFuncs,\n    filterLog: FormatFuncs,\n};\n\nexport class Formatter {\n    readonly formats: Formats;\n\n    constructor() {\n        this.formats = this.getDefaultFormats();\n    }\n\n    getDefaultFormats(): Formats {\n        const formats: Formats = <Formats>({ });\n\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n\n        const strictData = (v: any) => { return this.data(v, true); };\n\n        formats.transaction = {\n            hash: hash,\n\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n\n            confirmations: Formatter.allowNull(number, null),\n\n            from: address,\n\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n\n            creates: Formatter.allowNull(address, null),\n\n            raw: Formatter.allowNull(data),\n        };\n\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),// @TODO: should this be data?\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n\n            miner: Formatter.allowNull(address),\n            extraData: data,\n\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n\n            topics: Formatter.arrayOf(hash),\n\n            transactionHash: hash,\n            logIndex: number,\n        };\n\n        return formats;\n    }\n\n    accessList(accessList: Array<any>): AccessList {\n        return accessListify(accessList || []);\n    }\n\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number: any): number {\n        if (number === \"0x\") { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    type(number: any): number {\n        if (number === \"0x\" || number == null) { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    // Strict! Used on input.\n    bigNumber(value: any): BigNumber {\n        return BigNumber.from(value);\n    }\n\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value: any): boolean {\n        if (typeof(value) === \"boolean\") { return value; }\n        if (typeof(value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") { return true; }\n            if (value === \"false\") { return false; }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n\n    hex(value: any, strict?: boolean): string {\n        if (typeof(value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n            if (isHexString(value)) {\n               return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n\n    data(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n\n    // Requires an address\n    // Strict! Used on input.\n    address(value: any): string {\n        return getAddress(value);\n    }\n\n    callAddress(value: any): string {\n        if (!isHexString(value, 32)) { return null; }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null: address;\n    }\n\n    contractAddress(value: any): string {\n        return getContractAddress(value);\n    }\n\n    // Strict! Used on input.\n    blockTag(blockTag: any): string {\n        if (blockTag == null) { return \"latest\"; }\n\n        if (blockTag === \"earliest\") { return \"0x0\"; }\n\n        switch (blockTag) {\n            case \"earliest\": return \"0x0\";\n            case \"latest\": case \"pending\": case \"safe\": case \"finalized\":\n                return blockTag;\n        }\n\n        if (typeof(blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(<number | string>blockTag);\n        }\n\n        throw new Error(\"invalid blockTag\");\n    }\n\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value: any): number {\n        if (value == null) { return null; }\n\n        const v = BigNumber.from(value);\n\n        try {\n            return v.toNumber();\n        } catch (error) { }\n\n       return null;\n    }\n\n    uint256(value: any): string {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n\n    _block(value: any, format: any): Block {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty: value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null: BigNumber.from(difficulty));\n        return result;\n    }\n\n    block(value: any): Block {\n        return this._block(value, this.formats.block);\n    }\n\n    blockWithTransactions(value: any): Block {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n\n    // Strict! Used on input.\n    transactionRequest(value: any): any {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n\n    transactionResponse(transaction: any): TransactionResponse {\n\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n\n        if ((transaction.type === 1 || transaction.type === 2)&& transaction.accessList == null) {\n            transaction.accessList = [ ];\n        }\n\n        const result: TransactionResponse = Formatter.check(this.formats.transaction, transaction);\n\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            result.chainId = chainId;\n\n        } else {\n            let chainId = transaction.networkId;\n\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            if (typeof(chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) { chainId = 0; }\n                chainId = parseInt(chainId);\n            }\n\n            if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n            result.chainId = chainId;\n        }\n\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n\n        return result;\n    }\n\n    transaction(value: any): any {\n        return parseTransaction(value);\n    }\n\n    receiptLog(value: any): any {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n\n    receipt(value: any): TransactionReceipt {\n        const result: TransactionReceipt = Formatter.check(this.formats.receipt, value);\n\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                } else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            } else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n\n        return result;\n    }\n\n    topics(value: any): any {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n\n        } else if (value != null) {\n            return this.hash(value, true);\n        }\n\n        return null;\n    }\n\n    filter(value: any): any {\n        return Formatter.check(this.formats.filter, value);\n    }\n\n    filterLog(value: any): any {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n\n    static check(format: { [ name: string ]: FormatFunc }, object: any): any {\n        const result: any = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) { result[key] = value; }\n            } catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n\n    // if value is null-ish, nullValue is returned\n    static allowNull(format: FormatFunc, nullValue?: any): FormatFunc {\n        return (function(value: any) {\n            if (value == null) { return nullValue; }\n            return format(value);\n        });\n    }\n\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format: FormatFunc, replaceValue: any): FormatFunc {\n        return (function(value: any) {\n            if (!value) { return replaceValue; }\n            return format(value);\n        });\n    }\n\n    // Requires an Array satisfying check\n    static arrayOf(format: FormatFunc): FormatFunc {\n        return (function(array: any): Array<any> {\n            if (!Array.isArray(array)) { throw new Error(\"not an array\"); }\n\n            const result: any = [];\n\n            array.forEach(function(value) {\n                result.push(format(value));\n            });\n\n            return result;\n        });\n    }\n}\n\nexport interface CommunityResourcable {\n    isCommunityResource(): boolean;\n}\n\nexport function isCommunityResourcable(value: any): value is CommunityResourcable {\n    return (value && typeof(value.isCommunityResource) === \"function\");\n}\n\nexport function isCommunityResource(value: any): boolean {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) { return; }\n    throttleMessage = true;\n\n    console.log(\"========= NOTICE =========\")\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n\n","\"use strict\";\n\nimport {\n    Block, BlockTag, BlockWithTransactions, EventType, Filter, FilterByBlockHash, ForkEvent,\n    Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse\n} from \"@ethersproject/abstract-provider\";\nimport { encode as base64Encode } from \"@ethersproject/base64\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { dnsEncode, namehash } from \"@ethersproject/hash\";\nimport { getNetwork, Network, Networkish } from \"@ethersproject/networks\";\nimport { Deferrable, defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { Transaction } from \"@ethersproject/transactions\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\n\nimport bech32 from \"bech32\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Formatter } from \"./formatter\";\n\nconst MAX_CCIP_REDIRECTS = 10;\n\n//////////////////////////////\n// Event Serializeing\n\nfunction checkTopic(topic: string): string {\n     if (topic == null) { return \"null\"; }\n     if (hexDataLength(topic) !== 32) {\n         logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n     }\n     return topic.toLowerCase();\n}\n\nfunction serializeTopics(topics: Array<string | Array<string>>): string {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) { topics.pop(); }\n\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n\n            // Only track unique OR-topics\n            const unique: { [ topic: string ]: boolean } = { }\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n\n            return sorted.join(\"|\");\n\n        } else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\n\nfunction deserializeTopics(data: string): Array<string | Array<string>> {\n    if (data === \"\") { return [ ]; }\n\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") { return [ ]; }\n\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null: topic);\n        });\n\n        return ((comps.length === 1) ? comps[0]: comps);\n    });\n}\n\nfunction getEventTag(eventName: EventType): string {\n    if (typeof(eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n\n    } else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n\n    } else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n\n    } else if (eventName && typeof(eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n\n    throw new Error(\"invalid event - \" + eventName);\n}\n\n//////////////////////////////\n// Helper Object\n\nfunction getTime() {\n    return (new Date()).getTime();\n}\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\n//////////////////////////////\n// Provider Object\n\n\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\n\nconst PollableEvents = [ \"block\", \"network\", \"pending\", \"poll\" ];\n\nexport class Event {\n    readonly listener: Listener;\n    readonly once: boolean;\n    readonly tag: string;\n\n    _lastBlockNumber: number\n    _inflight: boolean;\n\n    constructor(tag: string, listener: Listener, once: boolean) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n\n    get event(): EventType {\n        switch (this.type) {\n            case \"tx\":\n               return this.hash;\n            case \"filter\":\n               return this.filter;\n        }\n        return this.tag;\n    }\n\n    get type(): string {\n        return this.tag.split(\":\")[0]\n    }\n\n    get hash(): string {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") { return null; }\n        return comps[1];\n    }\n\n    get filter(): Filter {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") { return null; }\n        const address = comps[1];\n\n        const topics = deserializeTopics(comps[2]);\n        const filter: Filter = { };\n\n        if (topics.length > 0) { filter.topics = topics; }\n        if (address && address !== \"*\") { filter.address = address; }\n\n        return filter;\n    }\n\n    pollable(): boolean {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n\nexport interface EnsResolver {\n\n    // Name this Resolver is associated with\n    readonly name: string;\n\n    // The address of the resolver\n    readonly address: string;\n\n    // Multichain address resolution (also normal address resolution)\n    // See: https://eips.ethereum.org/EIPS/eip-2304\n    getAddress(coinType?: 60): Promise<null | string>\n\n    // Contenthash field\n    // See: https://eips.ethereum.org/EIPS/eip-1577\n    getContentHash(): Promise<null | string>;\n\n    // Storage of text records\n    // See: https://eips.ethereum.org/EIPS/eip-634\n    getText(key: string): Promise<null | string>;\n};\n\nexport interface EnsProvider {\n    resolveName(name: string): Promise<null | string>;\n    lookupAddress(address: string): Promise<null | string>;\n    getResolver(name: string): Promise<null | EnsResolver>;\n}\n\ntype CoinInfo = {\n    symbol: string,\n    ilk?: string,     // General family\n    prefix?: string,  // Bech32 prefix\n    p2pkh?: number,   // Pay-to-Public-Key-Hash Version\n    p2sh?: number,    // Pay-to-Script-Hash Version\n};\n\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos: { [ coinType: string ]: CoinInfo } = {\n    \"0\":   { symbol: \"btc\",  p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\":   { symbol: \"ltc\",  p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\":   { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\":  { symbol: \"eth\",  ilk: \"eth\" },\n    \"61\":  { symbol: \"etc\",  ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\n\nfunction bytes32ify(value: number): string {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nexport interface Avatar {\n    url: string;\n    linkage: Array<{ type: string, content: string }>;\n}\n\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n\nfunction _parseString(result: string, start: number): null | string {\n    try {\n        return toUtf8String(_parseBytes(result, start));\n    } catch(error) { }\n    return null;\n}\n\nfunction _parseBytes(result: string, start: number): null | string {\n    if (result === \"0x\") { return null; }\n\n    const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link: string): string {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n\n    return `https:/\\/gateway.ipfs.io/ipfs/${ link }`;\n}\n\nfunction numPad(value: number): Uint8Array {\n    const result = arrayify(value);\n    if (result.length > 32) { throw new Error(\"internal; should not happen\"); }\n\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\n\nfunction bytesPad(value: Uint8Array): Uint8Array {\n    if ((value.length % 32) === 0) { return value; }\n\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas: Array<BytesLike>) {\n    const result: Array<Uint8Array> = [ ];\n\n    let byteCount = 0;\n\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(null);\n        byteCount += 32;\n    }\n\n    for (let i = 0; i < datas.length; i++) {\n        const data = arrayify(datas[i]);\n\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n\n    return hexConcat(result);\n}\n\nexport class Resolver implements EnsResolver {\n    readonly provider: BaseProvider;\n\n    readonly name: string;\n    readonly address: string;\n\n    readonly _resolvedAddress: null | string;\n\n    // For EIP-2544 names, the ancestor that provided the resolver\n    _supportsEip2544: null | Promise<boolean>;\n\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider: BaseProvider, address: string, name: string, resolvedAddress?: string) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n\n    supportsWildcard(): Promise<boolean> {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result) => {\n                return BigNumber.from(result).eq(1);\n            }).catch((error) => {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return false; }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n\n        return this._supportsEip2544;\n    }\n\n    async _fetch(selector: string, parameters?: string): Promise<null | string> {\n\n        // e.g. keccak256(\"addr(bytes32,uint256)\")\n        const tx = {\n            to: this.address,\n            ccipReadEnabled: true,\n            data: hexConcat([ selector, namehash(this.name), (parameters || \"0x\") ])\n        };\n\n        // Wildcard support; use EIP-2544 to resolve the request\n        let parseBytes = false;\n        if (await this.supportsWildcard()) {\n            parseBytes = true;\n\n            // selector(\"resolve(bytes,bytes)\")\n            tx.data = hexConcat([ \"0x9061b923\", encodeBytes([ dnsEncode(this.name), tx.data ]) ]);\n        }\n\n        try {\n            let result = await this.provider.call(tx);\n            if ((arrayify(result).length % 32) === 4) {\n                logger.throwError(\"resolver threw error\", Logger.errors.CALL_EXCEPTION, {\n                    transaction: tx, data: result\n                });\n            }\n            if (parseBytes) { result = _parseBytes(result, 0); }\n            return result;\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            throw error;\n        }\n    }\n\n    async _fetchBytes(selector: string, parameters?: string): Promise<null | string> {\n        const result = await this._fetch(selector, parameters);\n        if (result != null) { return _parseBytes(result, 0); }\n        return null;\n    }\n\n    _getAddress(coinType: number, hexBytes: string): string {\n        const coinInfo = coinInfos[String(coinType)];\n\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${ coinType }`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`\n            });\n        }\n\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n\n        const bytes = arrayify(hexBytes);\n\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2pkh ], (\"0x\" + p2pkh[2]) ]));\n                }\n            }\n        }\n\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2sh ], (\"0x\" + p2sh[2]) ]));\n                }\n            }\n        }\n\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            } else {\n                version = -1;\n            }\n\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n\n        return null;\n    }\n\n\n    async getAddress(coinType?: number): Promise<string> {\n        if (coinType == null) { coinType = 60; }\n\n        // If Ethereum, use the standard `addr(bytes32)`\n        if (coinType === 60) {\n            try {\n                // keccak256(\"addr(bytes32)\")\n                const result = await this._fetch(\"0x3b3b57de\");\n\n                // No address\n                if (result === \"0x\" || result === HashZero) { return null; }\n\n                return this.provider.formatter.callAddress(result);\n            } catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n                throw error;\n            }\n        }\n\n        // keccak256(\"addr(bytes32,uint256\")\n        const hexBytes = await this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n\n        // No address\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // Compute the address\n        const address = this._getAddress(coinType, hexBytes);\n\n        if (address == null) {\n            logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`,\n                coinType: coinType,\n                data: hexBytes\n            });\n        }\n\n        return address;\n    }\n\n    async getAvatar(): Promise<null | Avatar> {\n        const linkage: Array<{ type: string, content: string }> = [ { type: \"name\", content: this.name } ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) { return null; }\n\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n                if (match == null) { continue; }\n\n                const scheme = match[1].toLowerCase();\n\n                switch (scheme) {\n                    case \"https\":\n                        linkage.push({ type: \"url\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"data\":\n                        linkage.push({ type: \"data\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"ipfs\":\n                        linkage.push({ type: \"ipfs\", content: avatar });\n                        return { linkage, url: getIpfsLink(avatar) };\n\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (scheme === \"erc721\") ? \"0xc87b56dd\": \"0x0e89341c\";\n                        linkage.push({ type: scheme, content: avatar });\n\n                        // The owner of this name\n                        const owner = (this._resolvedAddress || await this.getAddress());\n\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) { return null; }\n\n                        const addr = await this.provider.formatter.address(comps[0]);\n                        const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n\n                        // Check that this account owns the token\n                        if (scheme === \"erc721\") {\n                            // ownerOf(uint256 tokenId)\n                            const tokenOwner = this.provider.formatter.callAddress(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x6352211e\", tokenId ])\n                            }));\n                            if (owner !== tokenOwner) { return null; }\n                            linkage.push({ type: \"owner\", content: tokenOwner });\n\n                        } else if (scheme === \"erc1155\") {\n                            // balanceOf(address owner, uint256 tokenId)\n                            const balance = BigNumber.from(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x00fdd58e\", hexZeroPad(owner, 32), tokenId ])\n                            }));\n                            if (balance.isZero()) { return null; }\n                            linkage.push({ type: \"balance\", content: balance.toString() });\n                        }\n\n                        // Call the token contract for the metadata URL\n                        const tx = {\n                            to: this.provider.formatter.address(comps[0]),\n                            data: hexConcat([ selector, tokenId ])\n                        };\n\n                        let metadataUrl = _parseString(await this.provider.call(tx), 0);\n                        if (metadataUrl == null) { return null; }\n                        linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                        }\n\n                        // Transform IPFS metadata links\n                        if (metadataUrl.match(/^ipfs:/i)) {\n                            metadataUrl = getIpfsLink(metadataUrl);\n                        }\n\n                        linkage.push({ type: \"metadata-url\", content: metadataUrl });\n\n                        // Get the token metadata\n                        const metadata = await fetchJson(metadataUrl);\n                        if (!metadata) { return null; }\n                        linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n\n                        // Pull the image URL out\n                        let imageUrl = metadata.image;\n                        if (typeof(imageUrl) !== \"string\") { return null; }\n\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        } else {\n                            // Transform IPFS link to gateway\n                            const ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) { return null; }\n\n                            linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n\n                        linkage.push({ type: \"url\", content: imageUrl });\n\n                        return { linkage, url: imageUrl };\n                    }\n                }\n            }\n        } catch (error) { }\n\n        return null;\n    }\n\n    async getContentHash(): Promise<string> {\n\n        // keccak256(\"contenthash()\")\n        const hexBytes = await this._fetchBytes(\"0xbc1c58d1\");\n\n        // No contenthash\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // IPFS (CID: 1, Type: DAG-PB)\n        const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const length = parseInt(ipfs[3], 16);\n            if (ipfs[4].length === length * 2) {\n                return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n            }\n        }\n\n        // IPNS (CID: 1, Type: libp2p-key)\n        const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipns) {\n            const length = parseInt(ipns[3], 16);\n            if (ipns[4].length === length * 2) {\n                return \"ipns:/\\/\" + Base58.encode(\"0x\" + ipns[1]);\n            }\n        }\n\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/)\n        if (swarm) {\n            if (swarm[1].length === (32 * 2)) {\n                return \"bzz:/\\/\" + swarm[1]\n            }\n        }\n\n        const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n        if (skynet) {\n            if (skynet[1].length === (34 * 2)) {\n                // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5\n                const urlSafe: Record<string, string> = { \"=\": \"\", \"+\": \"-\", \"/\": \"_\" };\n                const hash = base64Encode(\"0x\" + skynet[1]).replace(/[=+\\/]/g, (a) => (urlSafe[a]));\n                return \"sia:/\\/\" + hash;\n            }\n        }\n\n        return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"getContentHash()\",\n            data: hexBytes\n        });\n    }\n\n    async getText(key: string): Promise<string> {\n\n        // The key encoded as parameter to fetchBytes\n        let keyBytes = toUtf8Bytes(key);\n\n        // The nodehash consumes the first slot, so the string pointer targets\n        // offset 64, with the length at offset 64 and data starting at offset 96\n        keyBytes = concat([ bytes32ify(64), bytes32ify(keyBytes.length), keyBytes ]);\n\n        // Pad to word-size (32 bytes)\n        if ((keyBytes.length % 32) !== 0) {\n            keyBytes = concat([ keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32)) ])\n        }\n\n        const hexBytes = await this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        return toUtf8String(hexBytes);\n    }\n}\n\nlet defaultFormatter: Formatter = null;\n\nlet nextPollId = 1;\n\nexport class BaseProvider extends Provider implements EnsProvider {\n    _networkPromise: Promise<Network>;\n    _network: Network;\n\n    _events: Array<Event>;\n\n    formatter: Formatter;\n\n    // To help mitigate the eventually consistent nature of the blockchain\n    // we keep a mapping of events we emit. If we emit an event X, we expect\n    // that a user should be able to query for that event in the callback,\n    // if the node returns null, we stall the response until we get back a\n    // meaningful value, since we may be hitting a re-org, or a node that\n    // has not indexed the event yet.\n    // Events:\n    //   - t:{hash}    - Transaction hash\n    //   - b:{hash}    - BlockHash\n    //   - block       - The most recent emitted block\n    _emitted: { [ eventName: string ]: number | \"pending\" };\n\n    _pollingInterval: number;\n    _poller: NodeJS.Timer;\n    _bootstrapPoll: NodeJS.Timer;\n\n    _lastBlockNumber: number;\n    _maxFilterBlockRange: number;\n\n    _fastBlockNumber: number;\n    _fastBlockNumberPromise: Promise<number>;\n    _fastQueryDate: number;\n\n    _maxInternalBlockNumber: number;\n    _internalBlockNumber: Promise<{ blockNumber: number, reqTime: number, respTime: number }>;\n\n    readonly anyNetwork: boolean;\n\n    disableCcipRead: boolean;\n\n\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n\n    constructor(network: Networkish | Promise<Network>) {\n        super();\n\n        // Events being listened to\n        this._events = [];\n\n        this._emitted = { block: -2 };\n\n        this.disableCcipRead = false;\n\n        this.formatter = new.target.getFormatter();\n\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) { network = this.detectNetwork(); }\n\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n\n        } else {\n            const knownNetwork = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n\n            } else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n\n        this._maxInternalBlockNumber = -1024;\n\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n\n        this._pollingInterval = 4000;\n\n        this._fastQueryDate = 0;\n    }\n\n    async _ready(): Promise<Network> {\n        if (this._network == null) {\n            let network: Network = null;\n            if (this._networkPromise) {\n                try {\n                    network = await this._networkPromise;\n                } catch (error) { }\n            }\n\n            // Try the Provider's network detection (this MUST throw if it cannot)\n            if (network == null) {\n                network = await this.detectNetwork();\n            }\n\n            // This should never happen; every Provider sub-class should have\n            // suggested a network by here (or have thrown).\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // Possible this call stacked so do not call defineReadOnly again\n            if (this._network == null) {\n                if (this.anyNetwork) {\n                    this._network = network;\n                } else {\n                    defineReadOnly(this, \"_network\", network);\n                }\n                this.emit(\"network\", network, null);\n            }\n        }\n\n        return this._network;\n    }\n\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready(): Promise<Network> {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter(): Formatter {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network: Networkish): Network {\n        return getNetwork((network == null) ? \"homestead\": network);\n    }\n\n    async ccipReadFetch(tx: Transaction, calldata: string, urls: Array<string>): Promise<null | string> {\n        if (this.disableCcipRead || urls.length === 0) { return null; }\n\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n\n        const errorMessages: Array<string> = [ ];\n\n        for (let i = 0; i < urls.length; i++) {\n            const url = urls[i];\n\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n\n            // If no {data} is present, use POST; otherwise GET\n            const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n\n            const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n                value.status = response.statusCode;\n                return value;\n            });\n\n            if (result.data) { return result.data; }\n\n            const errorMessage = (result.message || \"unknown error\");\n\n            // 4xx indicates the result is not present; stop\n            if (result.status >= 400 && result.status < 500) {\n                return logger.throwError(`response not found during CCIP fetch: ${ errorMessage }`, Logger.errors.SERVER_ERROR, { url, errorMessage });\n            }\n\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n\n        return logger.throwError(`error encountered during CCIP fetch: ${ errorMessages.map((m) => JSON.stringify(m)).join(\", \") }`, Logger.errors.SERVER_ERROR, {\n            urls, errorMessages\n        });\n    }\n\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    async _getInternalBlockNumber(maxAge: number): Promise<number> {\n        await this._ready();\n\n        // Allowing stale data up to maxAge old\n        if (maxAge > 0) {\n\n            // While there are pending internal block requests...\n            while (this._internalBlockNumber) {\n\n                // ...\"remember\" which fetch we started with\n                const internalBlockNumber = this._internalBlockNumber;\n\n                try {\n                    // Check the result is not too stale\n                    const result = await internalBlockNumber;\n                    if ((getTime() - result.respTime) <= maxAge) {\n                        return result.blockNumber;\n                    }\n\n                    // Too old; fetch a new value\n                    break;\n\n                } catch(error) {\n\n                    // The fetch rejected; if we are the first to get the\n                    // rejection, drop through so we replace it with a new\n                    // fetch; all others blocked will then get that fetch\n                    // which won't match the one they \"remembered\" and loop\n                    if (this._internalBlockNumber === internalBlockNumber) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        const reqTime = getTime();\n\n        const checkInternalBlockNumber = resolveProperties({\n            blockNumber: this.perform(\"getBlockNumber\", { }),\n            networkError: this.getNetwork().then((network) => (null), (error) => (error))\n        }).then(({ blockNumber, networkError }) => {\n            if (networkError) {\n                // Unremember this bad internal block number\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n                throw networkError;\n            }\n\n            const respTime = getTime();\n\n            blockNumber = BigNumber.from(blockNumber).toNumber();\n            if (blockNumber < this._maxInternalBlockNumber) { blockNumber = this._maxInternalBlockNumber; }\n\n            this._maxInternalBlockNumber = blockNumber;\n            this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n            return { blockNumber, reqTime, respTime };\n        });\n\n        this._internalBlockNumber = checkInternalBlockNumber;\n\n        // Swallow unhandled exceptions; if needed they are handled else where\n        checkInternalBlockNumber.catch((error) => {\n            // Don't null the dead (rejected) fetch, if it has already been updated\n            if (this._internalBlockNumber === checkInternalBlockNumber) {\n                this._internalBlockNumber = null;\n            }\n        });\n\n        return (await checkInternalBlockNumber).blockNumber;\n    }\n\n    async poll(): Promise<void> {\n        const pollId = nextPollId++;\n\n        // Track all running promises, so we can trigger a post-poll once they are complete\n        const runners: Array<Promise<void>> = [];\n\n        let blockNumber: number = null;\n        try {\n            blockNumber = await this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n        } catch (error) {\n            this.emit(\"error\", error);\n            return;\n        }\n        this._setFastBlockNumber(blockNumber);\n\n        // Emit a poll event after we have the latest (fast) block number\n        this.emit(\"poll\", pollId, blockNumber);\n\n        // If the block has not changed, meh.\n        if (blockNumber === this._lastBlockNumber) {\n            this.emit(\"didPoll\", pollId);\n            return;\n        }\n\n        // First polling cycle, trigger a \"block\" events\n        if (this._emitted.block === -2) {\n            this._emitted.block = blockNumber - 1;\n        }\n\n        if (Math.abs((<number>(this._emitted.block)) - blockNumber) > 1000) {\n            logger.warn(`network block skew detected; skipping block events (emitted=${ this._emitted.block } blockNumber${ blockNumber })`);\n            this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                blockNumber: blockNumber,\n                event: \"blockSkew\",\n                previousBlockNumber: this._emitted.block\n            }));\n            this.emit(\"block\", blockNumber);\n\n        } else {\n            // Notify all listener for each block that has passed\n            for (let i = (<number>this._emitted.block) + 1; i <= blockNumber; i++) {\n                this.emit(\"block\", i);\n            }\n        }\n\n        // The emitted block was updated, check for obsolete events\n        if ((<number>this._emitted.block) !== blockNumber) {\n            this._emitted.block = blockNumber;\n\n            Object.keys(this._emitted).forEach((key) => {\n                // The block event does not expire\n                if (key === \"block\") { return; }\n\n                // The block we were at when we emitted this event\n                const eventBlockNumber = this._emitted[key];\n\n                // We cannot garbage collect pending transactions or blocks here\n                // They should be garbage collected by the Provider when setting\n                // \"pending\" events\n                if (eventBlockNumber === \"pending\") { return; }\n\n                // Evict any transaction hashes or block hashes over 12 blocks\n                // old, since they should not return null anyways\n                if (blockNumber - eventBlockNumber > 12) {\n                    delete this._emitted[key];\n                }\n            });\n        }\n\n        // First polling cycle\n        if (this._lastBlockNumber === -2) {\n            this._lastBlockNumber = blockNumber - 1;\n        }\n        // Find all transaction hashes we are waiting on\n        this._events.forEach((event) => {\n            switch (event.type) {\n                case \"tx\": {\n                    const hash = event.hash;\n                    let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt || receipt.blockNumber == null) { return null; }\n                        this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                        this.emit(hash, receipt);\n                        return null;\n                    }).catch((error: Error) => { this.emit(\"error\", error); });\n\n                    runners.push(runner);\n\n                    break;\n                }\n\n                case \"filter\": {\n                    // We only allow a single getLogs to be in-flight at a time\n                    if (!event._inflight) {\n                        event._inflight = true;\n\n                        // This is the first filter for this event, so we want to\n                        // restrict events to events that happened no earlier than now\n                        if (event._lastBlockNumber === -2) {\n                            event._lastBlockNumber = blockNumber - 1;\n                        }\n\n                        // Filter from the last *known* event; due to load-balancing\n                        // and some nodes returning updated block numbers before\n                        // indexing events, a logs result with 0 entries cannot be\n                        // trusted and we must retry a range which includes it again\n                        const filter = event.filter;\n                        filter.fromBlock = event._lastBlockNumber + 1;\n                        filter.toBlock = blockNumber;\n\n                        // Prevent fitler ranges from growing too wild, since it is quite\n                        // likely there just haven't been any events to move the lastBlockNumber.\n                        const minFromBlock = filter.toBlock - this._maxFilterBlockRange;\n                        if (minFromBlock > filter.fromBlock) { filter.fromBlock = minFromBlock; }\n\n                        if (filter.fromBlock < 0) { filter.fromBlock = 0; }\n\n                        const runner = this.getLogs(filter).then((logs) => {\n                            // Allow the next getLogs\n                            event._inflight = false;\n\n                            if (logs.length === 0) { return; }\n\n                            logs.forEach((log: Log) => {\n                                // Only when we get an event for a given block number\n                                // can we trust the events are indexed\n                                if (log.blockNumber > event._lastBlockNumber) {\n                                    event._lastBlockNumber = log.blockNumber;\n                                }\n\n                                // Make sure we stall requests to fetch blocks and txs\n                                this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n\n                                this.emit(filter, log);\n                            });\n                        }).catch((error: Error) => {\n                            this.emit(\"error\", error);\n\n                            // Allow another getLogs (the range was not updated)\n                            event._inflight = false;\n                        });\n                        runners.push(runner);\n                    }\n\n                    break;\n                }\n            }\n        });\n\n        this._lastBlockNumber = blockNumber;\n\n        // Once all events for this loop have been processed, emit \"didPoll\"\n        Promise.all(runners).then(() => {\n            this.emit(\"didPoll\", pollId);\n        }).catch((error) => { this.emit(\"error\", error); });\n\n        return;\n    }\n\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber: number): void {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) { this.poll(); }\n    }\n\n    get network(): Network {\n        return this._network;\n    }\n\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    async detectNetwork(): Promise<Network> {\n        return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"provider.detectNetwork\"\n        });\n    }\n\n    async getNetwork(): Promise<Network> {\n        const network = await this._ready();\n\n        // Make sure we are still connected to the same network; this is\n        // only an external call for backends which can have the underlying\n        // network change spontaneously\n        const currentNetwork = await this.detectNetwork();\n        if (network.chainId !== currentNetwork.chainId) {\n\n            // We are allowing network changes, things can get complex fast;\n            // make sure you know what you are doing if you use \"any\"\n            if (this.anyNetwork) {\n                this._network = currentNetwork;\n\n                // Reset all internal block number guards and caches\n                this._lastBlockNumber = -2;\n                this._fastBlockNumber = null;\n                this._fastBlockNumberPromise = null;\n                this._fastQueryDate = 0;\n                this._emitted.block = -2;\n                this._maxInternalBlockNumber = -1024;\n                this._internalBlockNumber = null;\n\n                // The \"network\" event MUST happen before this method resolves\n                // so any events have a chance to unregister, so we stall an\n                // additional event loop before returning from /this/ call\n                this.emit(\"network\", currentNetwork, network);\n                await stall(0);\n\n                return this._network;\n            }\n\n            const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                event: \"changed\",\n                network: network,\n                detectedNetwork: currentNetwork\n            });\n\n            this.emit(\"error\", error);\n            throw error;\n        }\n\n        return network;\n    }\n\n    get blockNumber(): number {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber: -1;\n    }\n\n    get polling(): boolean {\n        return (this._poller != null);\n    }\n\n    set polling(value: boolean) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) { this.poll(); }\n\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n\n        } else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n\n    get pollingInterval(): number {\n        return this._pollingInterval;\n    }\n\n    set pollingInterval(value: number) {\n        if (typeof(value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n\n        this._pollingInterval = value;\n\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n\n    _getFastBlockNumber(): Promise<number> {\n        const now = getTime();\n\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n\n        return this._fastBlockNumberPromise;\n    }\n\n    _setFastBlockNumber(blockNumber: number): void {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) { return; }\n\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n\n    async waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt> {\n        return this._waitForTransaction(transactionHash, (confirmations == null) ? 1: confirmations, timeout || 0, null);\n    }\n\n    async _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: { data: string, from: string, nonce: number, to: string, value: BigNumber, startBlock: number }): Promise<TransactionReceipt> {\n        const receipt = await this.getTransactionReceipt(transactionHash);\n\n        // Receipt is already good\n        if ((receipt ? receipt.confirmations: 0) >= confirmations) { return receipt; }\n\n        // Poll until the receipt is good...\n        return new Promise((resolve, reject) => {\n            const cancelFuncs: Array<() => void> = [];\n\n            let done = false;\n            const alreadyDone = function() {\n                if (done) { return true; }\n                done = true;\n                cancelFuncs.forEach((func) => { func(); });\n                return false;\n            };\n\n            const minedHandler = (receipt: TransactionReceipt) => {\n                if (receipt.confirmations < confirmations) { return; }\n                if (alreadyDone()) { return; }\n                resolve(receipt);\n            }\n            this.on(transactionHash, minedHandler);\n            cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n\n            if (replaceable) {\n                let lastBlockNumber = replaceable.startBlock;\n                let scannedBlock: number = null;\n                const replaceHandler = async (blockNumber: number) => {\n                    if (done) { return; }\n\n                    // Wait 1 second; this is only used in the case of a fault, so\n                    // we will trade off a little bit of latency for more consistent\n                    // results and fewer JSON-RPC calls\n                    await stall(1000);\n\n                    this.getTransactionCount(replaceable.from).then(async (nonce) => {\n                        if (done) { return; }\n\n                        if (nonce <= replaceable.nonce) {\n                            lastBlockNumber = blockNumber;\n\n                        } else {\n                            // First check if the transaction was mined\n                            {\n                                const mined = await this.getTransaction(transactionHash);\n                                if (mined && mined.blockNumber != null) { return; }\n                            }\n\n                            // First time scanning. We start a little earlier for some\n                            // wiggle room here to handle the eventually consistent nature\n                            // of blockchain (e.g. the getTransactionCount was for a\n                            // different block)\n                            if (scannedBlock == null) {\n                                scannedBlock = lastBlockNumber - 3;\n                                if (scannedBlock < replaceable.startBlock) {\n                                    scannedBlock = replaceable.startBlock;\n                                }\n                            }\n\n                            while (scannedBlock <= blockNumber) {\n                                if (done) { return; }\n\n                                const block = await this.getBlockWithTransactions(scannedBlock);\n                                for (let ti = 0; ti < block.transactions.length; ti++) {\n                                    const tx = block.transactions[ti];\n\n                                    // Successfully mined!\n                                    if (tx.hash === transactionHash) { return; }\n\n                                    // Matches our transaction from and nonce; its a replacement\n                                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                        if (done) { return; }\n\n                                        // Get the receipt of the replacement\n                                        const receipt = await this.waitForTransaction(tx.hash, confirmations);\n\n                                        // Already resolved or rejected (prolly a timeout)\n                                        if (alreadyDone()) { return; }\n\n                                        // The reason we were replaced\n                                        let reason = \"replaced\";\n                                        if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                            reason = \"repriced\";\n                                        } else  if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                            reason = \"cancelled\"\n                                        }\n\n                                        // Explain why we were replaced\n                                        reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                            reason,\n                                            replacement: this._wrapTransaction(tx),\n                                            hash: transactionHash,\n                                            receipt\n                                        }));\n\n                                        return;\n                                    }\n                                }\n                                scannedBlock++;\n                            }\n                        }\n\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n\n                    }, (error) => {\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n                    });\n                };\n\n                if (done) { return; }\n                this.once(\"block\", replaceHandler);\n\n                cancelFuncs.push(() => {\n                    this.removeListener(\"block\", replaceHandler);\n                });\n            }\n\n            if (typeof(timeout) === \"number\" && timeout > 0) {\n                const timer = setTimeout(() => {\n                    if (alreadyDone()) { return; }\n                    reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                }, timeout);\n                if (timer.unref) { timer.unref(); }\n\n                cancelFuncs.push(() => { clearTimeout(timer); });\n            }\n        });\n    }\n\n    async getBlockNumber(): Promise<number> {\n        return this._getInternalBlockNumber(0);\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        await this.getNetwork();\n\n        const result = await this.perform(\"getGasPrice\", { });\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getGasPrice\",\n                result, error\n            });\n        }\n    }\n\n    async getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getBalance\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getBalance\",\n                params, result, error\n            });\n        }\n    }\n\n    async getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getTransactionCount\", params);\n        try {\n            return BigNumber.from(result).toNumber();\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getTransactionCount\",\n                params, result, error\n            });\n        }\n    }\n\n    async getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getCode\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getCode\",\n                params, result, error\n            });\n        }\n    }\n\n    async getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag),\n            position: Promise.resolve(position).then((p) => hexValue(p))\n        });\n        const result = await this.perform(\"getStorageAt\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getStorageAt\",\n                params, result, error\n            });\n        }\n    }\n\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx: Transaction, hash?: string, startBlock?: number): TransactionResponse {\n        if (hash != null && hexDataLength(hash) !== 32) { throw new Error(\"invalid response - sendTransaction\"); }\n\n        const result = <TransactionResponse>tx;\n\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n\n        result.wait = async (confirms?: number, timeout?: number) => {\n            if (confirms == null) { confirms = 1; }\n            if (timeout == null) { timeout = 0; }\n\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n\n            const receipt = await this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) { return null; }\n\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        };\n\n        return result;\n    }\n\n    async sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        const hexTx = await Promise.resolve(signedTransaction).then(t => hexlify(t));\n        const tx = this.formatter.transaction(signedTransaction);\n        if (tx.confirmations == null) { tx.confirmations = 0; }\n        const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n        try {\n            const hash = await this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n            return this._wrapTransaction(tx, hash, blockNumber);\n        } catch (error) {\n            (<any>error).transaction = tx;\n            (<any>error).transactionHash = tx.hash;\n            throw error;\n        }\n    }\n\n    async _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<Transaction> {\n        const values: any = await transaction;\n\n        const tx: any = { };\n\n        [\"from\", \"to\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v): null))\n        });\n\n        [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v): null));\n        });\n\n        [\"type\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v: null));\n        });\n\n        if (values.accessList) {\n            tx.accessList = this.formatter.accessList(values.accessList);\n        }\n\n        [\"data\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v): null));\n        });\n\n        return this.formatter.transactionRequest(await resolveProperties(tx));\n    }\n\n    async _getFilter(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Filter | FilterByBlockHash> {\n        filter = await filter;\n\n        const result: any = { };\n\n        if (filter.address != null) {\n            result.address = this._getAddress(filter.address);\n        }\n\n        [\"blockHash\", \"topics\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = (<any>filter)[key];\n        });\n\n        [\"fromBlock\", \"toBlock\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = this._getBlockTag((<any>filter)[key]);\n        });\n\n        return this.formatter.filter(await resolveProperties(result));\n    }\n\n    async _call(transaction: TransactionRequest, blockTag: BlockTag, attempt: number): Promise<string> {\n        if (attempt >= MAX_CCIP_REDIRECTS) {\n            logger.throwError(\"CCIP read exceeded maximum redirections\", Logger.errors.SERVER_ERROR, {\n                redirects: attempt, transaction\n            });\n        }\n\n        const txSender = transaction.to;\n\n        const result = await this.perform(\"call\", { transaction, blockTag });\n\n        // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n        if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && (hexDataLength(result) % 32 === 4)) {\n            try {\n                const data = hexDataSlice(result, 4);\n\n                // Check the sender of the OffchainLookup matches the transaction\n                const sender = hexDataSlice(data, 0, 32);\n                if (!BigNumber.from(sender).eq(txSender)) {\n                    logger.throwError(\"CCIP Read sender did not match\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n\n                // Read the URLs from the response\n                const urls: Array<string> = [];\n                const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();\n                const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();\n                const urlsData = hexDataSlice(data, urlsOffset + 32);\n                for (let u = 0; u < urlsLength; u++) {\n                    const url = _parseString(urlsData, u * 32);\n                    if (url == null) {\n                        logger.throwError(\"CCIP Read contained corrupt URL string\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    urls.push(url);\n                }\n\n                // Get the CCIP calldata to forward\n                const calldata = _parseBytes(data, 64);\n\n                // Get the callbackSelector (bytes4)\n                if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {\n                    logger.throwError(\"CCIP Read callback selector included junk\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n                const callbackSelector = hexDataSlice(data, 96, 100);\n\n                // Get the extra data to send back to the contract as context\n                const extraData = _parseBytes(data, 128);\n\n                const ccipResult = await this.ccipReadFetch(<Transaction>transaction, calldata, urls);\n                if (ccipResult == null) {\n                    logger.throwError(\"CCIP Read disabled or provided no URLs\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n\n                const tx = {\n                    to: txSender,\n                    data: hexConcat([ callbackSelector, encodeBytes([ ccipResult, extraData ]) ])\n                };\n\n                return this._call(tx, blockTag, attempt + 1);\n\n            } catch (error) {\n                if (error.code === Logger.errors.SERVER_ERROR) { throw error; }\n            }\n        }\n\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"call\",\n                params: { transaction, blockTag }, result, error\n            });\n        }\n\n    }\n\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const resolved = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction),\n            blockTag: this._getBlockTag(blockTag),\n            ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n        });\n        return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0: -1);\n    }\n\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction)\n        });\n\n        const result = await this.perform(\"estimateGas\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"estimateGas\",\n                params, result, error\n            });\n        }\n    }\n\n    async _getAddress(addressOrName: string | Promise<string>): Promise<string> {\n        addressOrName = await addressOrName;\n        if (typeof(addressOrName) !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n        }\n\n        const address = await this.resolveName(addressOrName);\n        if (address == null) {\n            logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `resolveName(${ JSON.stringify(addressOrName) })`\n            });\n        }\n        return address;\n    }\n\n    async _getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>, includeTransactions?: boolean): Promise<Block | BlockWithTransactions> {\n        await this.getNetwork();\n\n        blockHashOrBlockTag = await blockHashOrBlockTag;\n\n        // If blockTag is a number (not \"latest\", etc), this is the block number\n        let blockNumber = -128;\n\n        const params: { [key: string]: any } = {\n            includeTransactions: !!includeTransactions\n        };\n\n        if (isHexString(blockHashOrBlockTag, 32)) {\n            params.blockHash = blockHashOrBlockTag;\n        } else {\n            try {\n                params.blockTag = await this._getBlockTag(blockHashOrBlockTag);\n                if (isHexString(params.blockTag)) {\n                    blockNumber = parseInt(params.blockTag.substring(2), 16);\n                }\n            } catch (error) {\n                logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n            }\n        }\n\n        return poll(async () => {\n            const block = await this.perform(\"getBlock\", params);\n\n            // Block was not found\n            if (block == null) {\n\n                // For blockhashes, if we didn't say it existed, that blockhash may\n                // not exist. If we did see it though, perhaps from a log, we know\n                // it exists, and this node is just not caught up yet.\n                if (params.blockHash != null) {\n                    if (this._emitted[\"b:\" + params.blockHash] == null) { return null; }\n                }\n\n                // For block tags, if we are asking for a future block, we return null\n                if (params.blockTag != null) {\n                    if (blockNumber > this._emitted.block) { return null; }\n                }\n\n                // Retry on the next block\n                return undefined;\n            }\n\n            // Add transactions\n            if (includeTransactions) {\n                let blockNumber: number = null;\n                for (let i = 0; i < block.transactions.length; i++) {\n                    const tx = block.transactions[i];\n                    if (tx.blockNumber == null) {\n                        tx.confirmations = 0;\n\n                    } else if (tx.confirmations == null) {\n                        if (blockNumber == null) {\n                            blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        }\n\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = (blockNumber - tx.blockNumber) + 1;\n                        if (confirmations <= 0) { confirmations = 1; }\n                        tx.confirmations = confirmations;\n                    }\n                }\n\n                const blockWithTxs: any = this.formatter.blockWithTransactions(block);\n                blockWithTxs.transactions = blockWithTxs.transactions.map((tx: TransactionResponse) => this._wrapTransaction(tx));\n                return blockWithTxs;\n            }\n\n            return this.formatter.block(block);\n\n        }, { oncePoll: this });\n    }\n\n    getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block> {\n        return <Promise<Block>>(this._getBlock(blockHashOrBlockTag, false));\n    }\n\n    getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions> {\n        return <Promise<BlockWithTransactions>>(this._getBlock(blockHashOrBlockTag, true));\n    }\n\n    async getTransaction(transactionHash: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransaction\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            const tx = this.formatter.transactionResponse(result);\n\n            if (tx.blockNumber == null) {\n                tx.confirmations = 0;\n\n            } else if (tx.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - tx.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                tx.confirmations = confirmations;\n            }\n\n            return this._wrapTransaction(tx);\n        }, { oncePoll: this });\n    }\n\n    async getTransactionReceipt(transactionHash: string | Promise<string>): Promise<TransactionReceipt> {\n        await this.getNetwork();\n\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransactionReceipt\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            // \"geth-etc\" returns receipts before they are ready\n            if (result.blockHash == null) { return undefined; }\n\n            const receipt = this.formatter.receipt(result);\n\n            if (receipt.blockNumber == null) {\n                receipt.confirmations = 0;\n\n            } else if (receipt.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                receipt.confirmations = confirmations;\n            }\n\n            return receipt;\n        }, { oncePoll: this });\n    }\n\n    async getLogs(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Array<Log>> {\n        await this.getNetwork();\n        const params = await resolveProperties({ filter: this._getFilter(filter) });\n        const logs: Array<Log> = await this.perform(\"getLogs\", params);\n        logs.forEach((log) => {\n            if (log.removed == null) { log.removed = false; }\n        });\n        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n    }\n\n    async getEtherPrice(): Promise<number> {\n        await this.getNetwork();\n        return this.perform(\"getEtherPrice\", { });\n    }\n\n    async _getBlockTag(blockTag: BlockTag | Promise<BlockTag>): Promise<BlockTag> {\n        blockTag = await blockTag;\n\n        if (typeof(blockTag) === \"number\" && blockTag < 0) {\n            if (blockTag % 1) {\n                logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n            }\n\n            let blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            blockNumber += blockTag;\n            if (blockNumber < 0) { blockNumber = 0; }\n            return this.formatter.blockTag(blockNumber)\n        }\n\n        return this.formatter.blockTag(blockTag);\n    }\n\n\n    async getResolver(name: string): Promise<null | Resolver> {\n        let currentName = name;\n        while (true) {\n            if (currentName === \"\" || currentName === \".\") { return null; }\n\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") { return null; }\n\n            // Check the current node for a resolver\n            const addr = await this._getResolver(currentName, \"getResolver\");\n\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new Resolver(this, addr, name);\n\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !(await resolver.supportsWildcard())) { return null; }\n\n                return resolver;\n            }\n\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n\n    }\n\n    async _getResolver(name: string, operation?: string): Promise<string> {\n        if (operation == null) { operation = \"ENS\"; }\n\n        const network = await this.getNetwork();\n\n        // No ENS...\n        if (!network.ensAddress) {\n            logger.throwError(\n                \"network does not support ENS\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { operation, network: network.name }\n            );\n        }\n\n        try {\n            // keccak256(\"resolver(bytes32)\")\n            const addrData = await this.call({\n                to: network.ensAddress,\n                data: (\"0x0178b8bf\" + namehash(name).substring(2))\n            });\n            return this.formatter.callAddress(addrData);\n        } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32)\n        }\n\n        return null;\n    }\n\n    async resolveName(name: string | Promise<string>): Promise<null | string> {\n        name = await name;\n\n        // If it is already an address, nothing to resolve\n        try {\n            return Promise.resolve(this.formatter.address(name));\n        } catch (error) {\n            // If is is a hexstring, the address is bad (See #694)\n            if (isHexString(name)) { throw error; }\n        }\n\n        if (typeof(name) !== \"string\") {\n            logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n        }\n\n        // Get the addr from the resolver\n        const resolver = await this.getResolver(name);\n        if (!resolver) { return null; }\n\n        return await resolver.getAddress();\n    }\n\n    async lookupAddress(address: string | Promise<string>): Promise<null | string> {\n        address = await address;\n        address = this.formatter.address(address);\n\n        const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n        const resolverAddr = await this._getResolver(node, \"lookupAddress\");\n        if (resolverAddr == null) { return null; }\n\n        // keccak(\"name(bytes32)\")\n        const name = _parseString(await this.call({\n            to: resolverAddr,\n            data: (\"0x691f3431\" + namehash(node).substring(2))\n        }), 0);\n\n        const addr = await this.resolveName(name);\n        if (addr != address) { return null; }\n\n        return name;\n    }\n\n    async getAvatar(nameOrAddress: string): Promise<null | string> {\n        let resolver: Resolver = null;\n        if (isHexString(nameOrAddress)) {\n            // Address; reverse lookup\n            const address = this.formatter.address(nameOrAddress);\n\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n            const resolverAddress = await this._getResolver(node, \"getAvatar\");\n            if (!resolverAddress) { return null; }\n\n            // Try resolving the avatar against the addr.reverse resolver\n            resolver = new Resolver(this, resolverAddress, node);\n            try {\n                const avatar = await resolver.getAvatar();\n                if (avatar) { return avatar.url; }\n            } catch (error) {\n                if (error.code !== Logger.errors.CALL_EXCEPTION) { throw error; }\n            }\n\n            // Try getting the name and performing forward lookup; allowing wildcards\n            try {\n                // keccak(\"name(bytes32)\")\n                const name = _parseString(await this.call({\n                    to: resolverAddress,\n                    data: (\"0x691f3431\" + namehash(node).substring(2))\n                }), 0);\n                resolver = await this.getResolver(name);\n            } catch (error) {\n                if (error.code !== Logger.errors.CALL_EXCEPTION) { throw error; }\n                return null;\n            }\n\n        } else {\n            // ENS name; forward lookup with wildcard\n            resolver = await this.getResolver(nameOrAddress);\n            if (!resolver) { return null; }\n        }\n\n        const avatar = await resolver.getAvatar();\n        if (avatar == null) { return null; }\n\n        return avatar.url;\n    }\n\n    perform(method: string, params: any): Promise<any> {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n\n    _startEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _stopEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _addEventListener(eventName: EventType, listener: Listener, once: boolean): this {\n        const event = new Event(getEventTag(eventName), listener, once)\n        this._events.push(event);\n        this._startEvent(event);\n\n        return this;\n    }\n\n    on(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, false);\n    }\n\n    once(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, true);\n    }\n\n\n    emit(eventName: EventType, ...args: Array<any>): boolean {\n        let result = false;\n\n        let stopped: Array<Event> = [ ];\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) { return true; }\n\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n\n            result = true;\n\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n\n            return true;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventType): number {\n        if (!eventName) { return this._events.length; }\n\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n\n    listeners(eventName?: EventType): Array<Listener> {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n\n    off(eventName: EventType, listener?: Listener): this {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n\n        const stopped: Array<Event> = [ ];\n\n        let found = false;\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) { return true; }\n            if (found) { return true; }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n\n    removeAllListeners(eventName?: EventType): this {\n        let stopped: Array<Event> = [ ];\n        if (eventName == null) {\n            stopped = this._events;\n\n            this._events = [ ];\n        } else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) { return true; }\n                stopped.push(event);\n                return false;\n            });\n        }\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n}\n","export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/JSON-RPC\n\nimport { Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Bytes, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { checkProperties, deepCopy, Deferrable, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { AccessList, accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson, poll } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider, Event } from \"./base-provider\";\n\n\nconst errorGas = [ \"call\", \"estimateGas\" ];\n\nfunction spelunk(value: any, requireData: boolean): null | { message: string, data: null | string } {\n    if (value == null) { return null; }\n\n    // These *are* the droids we're looking for.\n    if (typeof(value.message) === \"string\" && value.message.match(\"reverted\")) {\n        const data = isHexString(value.data) ? value.data: null;\n        if (!requireData || data) {\n            return { message: value.message, data };\n        }\n    }\n\n    // Spelunk further...\n    if (typeof(value) === \"object\") {\n        for (const key in value) {\n            const result = spelunk(value[key], requireData);\n            if (result) { return result; }\n        }\n        return null;\n    }\n\n    // Might be a JSON string we can further descend...\n    if (typeof(value) === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        } catch (error) { }\n    }\n\n    return null;\n}\n\nfunction checkError(method: string, error: any, params: any): any {\n\n    const transaction = params.transaction || params.signedTransaction;\n\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        const result = spelunk(error, true);\n        if (result) { return result.data; }\n\n        // Nothing descriptive..\n        logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\", transaction, error\n        });\n    }\n\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        let result = spelunk(error.body, false);\n        if (result == null) { result = spelunk(error, false); }\n\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message, method, transaction, error\n            });\n        }\n    }\n\n    // @TODO: Should we spelunk for message too?\n\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof(error.error.message) === \"string\") {\n        message = error.error.message;\n    } else if (typeof(error.body) === \"string\") {\n        message = error.body;\n    } else if (typeof(error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nfunction timer(timeout: number): Promise<any> {\n    return new Promise(function(resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\n\nfunction getResult(payload: { error?: { code?: number, data?: any, message?: string }, result?: any }): any {\n    if (payload.error) {\n        // @TODO: not any\n        const error: any = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n\n    return payload.result;\n}\n\nfunction getLowerCase(value: string): string {\n    if (value) { return value.toLowerCase(); }\n    return value;\n}\n\nconst _constructorGuard = {};\n\nexport class JsonRpcSigner extends Signer implements TypedDataSigner {\n    readonly provider: JsonRpcProvider;\n    _index: number;\n    _address: string;\n\n    constructor(constructorGuard: any, provider: JsonRpcProvider, addressOrIndex?: string | number) {\n        super();\n\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n\n        defineReadOnly(this, \"provider\", provider);\n\n        if (addressOrIndex == null) { addressOrIndex = 0; }\n\n        if (typeof(addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n\n        } else if (typeof(addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n\n        } else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n\n    connect(provider: Provider): JsonRpcSigner {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n\n    connectUnchecked(): JsonRpcSigner {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n\n    getAddress(): Promise<string> {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index])\n        });\n    }\n\n    sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        transaction = shallowCopy(transaction);\n\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) { address = address.toLowerCase(); }\n            return address;\n        });\n\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n        }\n\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            } else {\n                tx.from = sender;\n            }\n\n            const hexTx = (<any>this.provider.constructor).hexlifyTransaction(tx, { from: true });\n\n            return this.provider.send(\"eth_sendTransaction\", [ hexTx ]).then((hash) => {\n                return hash;\n            }, (error) => {\n                if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected transaction\", Logger.errors.ACTION_REJECTED, {\n                        action: \"sendTransaction\",\n                        transaction: tx\n                    });\n                }\n\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(transaction);\n\n        try {\n            // Unfortunately, JSON-RPC only provides and opaque transaction hash\n            // for a response, and we need the actual transaction, so we poll\n            // for it; it should show up very quickly\n            return await poll(async () => {\n                const tx = await this.provider.getTransaction(hash);\n                if (tx === null) { return undefined; }\n                return this.provider._wrapTransaction(tx, hash, blockNumber);\n            }, { oncePoll: this.provider });\n        } catch (error) {\n            (<any>error).transactionHash = hash;\n            throw error;\n        }\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n        try {\n            return await this.provider.send(\"personal_sign\", [ hexlify(data), address.toLowerCase() ]);\n        } catch (error) {\n            if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                    action: \"signMessage\",\n                    from: address,\n                    messageData: message\n                });\n            }\n            throw error;\n        }\n    }\n\n    async _legacySignMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        try {\n            // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n            return await this.provider.send(\"eth_sign\", [ address.toLowerCase(), hexlify(data) ]);\n        } catch (error) {\n            if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                    action: \"_legacySignMessage\",\n                    from: address,\n                    messageData: message\n                });\n            }\n            throw error;\n        }\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names (in-place)\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            return this.provider.resolveName(name);\n        });\n\n        const address = await this.getAddress();\n\n        try {\n            return await this.provider.send(\"eth_signTypedData_v4\", [\n                address.toLowerCase(),\n                JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n            ]);\n        } catch (error) {\n            if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                    action: \"_signTypedData\",\n                    from: address,\n                    messageData: { domain: populated.domain, types, value: populated.value }\n                });\n            }\n            throw error;\n        }\n    }\n\n    async unlock(password: string): Promise<boolean> {\n        const provider = this.provider;\n\n        const address = await this.getAddress();\n\n        return provider.send(\"personal_unlockAccount\", [ address.toLowerCase(), password, null ]);\n    }\n}\n\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return <TransactionResponse>{\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations?: number) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n}\n\nexport class JsonRpcProvider extends BaseProvider {\n    readonly connection: ConnectionInfo;\n\n    _pendingFilter: Promise<number>;\n    _nextId: number;\n\n    // During any given event loop, the results for a given call will\n    // all be the same, so we can dedup the calls to save requests and\n    // bandwidth. @TODO: Try out generalizing this against send?\n    _eventLoopCache: Record<string, Promise<any>>;\n    get _cache(): Record<string, Promise<any>> {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = { };\n        }\n        return this._eventLoopCache;\n    }\n\n    constructor(url?: ConnectionInfo | string, network?: Networkish) {\n        let networkOrReady: Networkish | Promise<Network> = network;\n\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Default URL\n        if (!url) { url = getStatic<() => string>(this.constructor, \"defaultUrl\")(); }\n\n        if (typeof(url) === \"string\") {\n            defineReadOnly(this, \"connection\",Object.freeze({\n                url: url\n            }));\n        } else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n\n        this._nextId = 42;\n    }\n\n    static defaultUrl(): string {\n        return \"http:/\\/localhost:8545\";\n    }\n\n    detectNetwork(): Promise<Network> {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n\n    async _uncachedDetectNetwork(): Promise<Network> {\n        await timer(0);\n\n        let chainId = null;\n        try {\n            chainId = await this.send(\"eth_chainId\", [ ]);\n        } catch (error) {\n            try {\n                chainId = await this.send(\"net_version\", [ ]);\n            } catch (error) { }\n        }\n\n        if (chainId != null) {\n            const getNetwork = getStatic<(network: Networkish) => Network>(this.constructor, \"getNetwork\");\n            try {\n                return getNetwork(BigNumber.from(chainId).toNumber());\n            } catch (error) {\n                return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                    chainId: chainId,\n                    event: \"invalidNetwork\",\n                    serverError: error\n                });\n            }\n        }\n\n        return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n            event: \"noNetwork\"\n        });\n    }\n\n    getSigner(addressOrIndex?: string | number): JsonRpcSigner {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n\n    getUncheckedSigner(addressOrIndex?: string | number): UncheckedJsonRpcSigner {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return this.send(\"eth_accounts\", []).then((accounts: Array<string>) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([ \"eth_chainId\", \"eth_blockNumber\" ].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n\n            return result;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n\n            throw error;\n        });\n\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n\n        return result;\n    }\n\n    prepareRequest(method: string, params: any): [ string, Array<any> ] {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [ \"eth_blockNumber\", [] ];\n\n            case \"getGasPrice\":\n                return [ \"eth_gasPrice\", [] ];\n\n            case \"getBalance\":\n                return [ \"eth_getBalance\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getTransactionCount\":\n                return [ \"eth_getTransactionCount\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getCode\":\n                return [ \"eth_getCode\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getStorageAt\":\n                return [ \"eth_getStorageAt\", [ getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag ] ];\n\n            case \"sendTransaction\":\n                return [ \"eth_sendRawTransaction\", [ params.signedTransaction ] ]\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [ \"eth_getBlockByNumber\", [ params.blockTag, !!params.includeTransactions ] ];\n                } else if (params.blockHash) {\n                    return [ \"eth_getBlockByHash\", [ params.blockHash, !!params.includeTransactions ] ];\n                }\n                return null;\n\n            case \"getTransaction\":\n                return [ \"eth_getTransactionByHash\", [ params.transactionHash ] ];\n\n            case \"getTransactionReceipt\":\n                return [ \"eth_getTransactionReceipt\", [ params.transactionHash ] ];\n\n            case \"call\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_call\", [ hexlifyTransaction(params.transaction, { from: true }), params.blockTag ] ];\n            }\n\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_estimateGas\", [ hexlifyTransaction(params.transaction, { from: true }) ] ];\n            }\n\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [ \"eth_getLogs\", [ params.filter ] ];\n\n            default:\n                break;\n        }\n\n        return null;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (method === \"call\" || method === \"estimateGas\") {\n            const tx = params.transaction;\n            if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                // If there are no EIP-1559 properties, it might be non-EIP-1559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        params = shallowCopy(params);\n                        params.transaction = shallowCopy(tx);\n                        delete params.transaction.type;\n                    }\n                }\n            }\n        }\n\n        const args = this.prepareRequest(method,  params);\n\n        if (args == null) {\n            logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n        }\n        try {\n            return await this.send(args[0], args[1])\n        } catch (error) {\n            return checkError(method, error, params);\n        }\n    }\n\n    _startEvent(event: Event): void {\n        if (event.tag === \"pending\") { this._startPending(); }\n        super._startEvent(event);\n    }\n\n    _startPending(): void {\n        if (this._pendingFilter != null) { return; }\n        const self = this;\n\n        const pendingFilter: Promise<number> = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n\n        pendingFilter.then(function(filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [ filterId ]).then(function(hashes: Array<string>) {\n                    if (self._pendingFilter != pendingFilter) { return null; }\n\n                    let seq = Promise.resolve();\n                    hashes.forEach(function(hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function() {\n                            return self.getTransaction(hash).then(function(tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n\n                    return seq.then(function() {\n                        return timer(1000);\n                    });\n                }).then(function() {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [ filterId ]);\n                        return;\n                    }\n                    setTimeout(function() { poll(); }, 0);\n\n                    return null;\n                }).catch((error: Error) => { });\n            }\n            poll();\n\n            return filterId;\n        }).catch((error: Error) => { });\n    }\n\n    _stopEvent(event: Event): void {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction: TransactionRequest, allowExtra?: { [key: string]: boolean }): { [key: string]: string | AccessList } {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) { allowed[key] = true; }\n            }\n        }\n\n        checkProperties(transaction, allowed);\n\n        const result: { [key: string]: string | AccessList } = {};\n\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            const value = hexValue(BigNumber.from((<any>transaction)[key]));\n            if (key === \"gasLimit\") { key = \"gas\"; }\n            result[key] = value;\n        });\n\n        [\"from\", \"to\", \"data\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            result[key] = hexlify((<any>transaction)[key]);\n        });\n\n        if ((<any>transaction).accessList) {\n            result[\"accessList\"] = accessListify((<any>transaction).accessList);\n        }\n\n        return result;\n    }\n}\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport type { GetUrlResponse, Options } from \"./types\";\n\nexport { GetUrlResponse, Options };\n\nexport async function getUrl(href: string, options?: Options): Promise<GetUrlResponse> {\n    if (options == null) { options = { }; }\n\n    const request: RequestInit = {\n        method: (options.method || \"GET\"),\n        headers: (options.headers || { }),\n        body: (options.body || undefined),\n    };\n\n    if (options.skipFetchSetup !== true) {\n        request.mode = <RequestMode>\"cors\";              // no-cors, cors, *same-origin\n        request.cache = <RequestCache>\"no-cache\";        // *default, no-cache, reload, force-cache, only-if-cached\n        request.credentials = <RequestCredentials>\"same-origin\";  // include, *same-origin, omit\n        request.redirect = <RequestRedirect>\"follow\";    // manual, *follow, error\n        request.referrer = \"client\";                     // no-referrer, *client\n    };\n\n    if (options.fetchOptions != null) {\n        const opts = options.fetchOptions;\n        if (opts.mode) { request.mode = <RequestMode>(opts.mode); }\n        if (opts.cache) { request.cache = <RequestCache>(opts.cache); }\n        if (opts.credentials) { request.credentials = <RequestCredentials>(opts.credentials); }\n        if (opts.redirect) { request.redirect = <RequestRedirect>(opts.redirect); }\n        if (opts.referrer) { request.referrer = opts.referrer; }\n    }\n\n    const response = await fetch(href, request);\n    const body = await response.arrayBuffer();\n\n    const headers: { [ name: string ]: string } = { };\n    if (response.headers.forEach) {\n        response.headers.forEach((value, key) => {\n            headers[key.toLowerCase()] = value;\n        });\n    } else {\n        (<() => Array<string>>((<any>(response.headers)).keys))().forEach((key) => {\n            headers[key.toLowerCase()] = response.headers.get(key);\n        });\n    }\n\n    return {\n        headers: headers,\n        statusCode: response.status,\n        statusMessage: response.statusText,\n        body: arrayify(new Uint8Array(body)),\n    }\n}\n","\"use strict\";\n\nimport { decode as base64Decode, encode as base64Encode } from \"@ethersproject/base64\";\nimport { hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { getUrl, GetUrlResponse, Options } from \"./geturl\";\n\nfunction staller(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\nfunction bodyify(value: any, type: string): string {\n    if (value == null) { return null; }\n\n    if (typeof(value) === \"string\") { return value; }\n\n    if (isBytesLike(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return toUtf8String(value);\n            } catch (error) { };\n        }\n        return hexlify(value);\n    }\n\n    return value;\n}\n\n// Exported Types\nexport type ConnectionInfo = {\n    url: string,\n    headers?: { [key: string]: string | number }\n\n    user?: string,\n    password?: string,\n\n    allowInsecureAuthentication?: boolean,\n    allowGzip?: boolean,\n\n    throttleLimit?: number,\n    throttleSlotInterval?: number;\n    throttleCallback?: (attempt: number, url: string) => Promise<boolean>,\n\n    skipFetchSetup?: boolean;\n    fetchOptions?: Record<string, string>;\n    errorPassThrough?: boolean;\n\n    timeout?: number,\n};\n\nexport interface OnceBlockable {\n    once(eventName: \"block\", handler: () => void): void;\n}\n\nexport interface OncePollable {\n    once(eventName: \"poll\", handler: () => void): void;\n}\n\nexport type PollOptions = {\n    timeout?: number,\n    floor?: number,\n    ceiling?: number,\n    interval?: number,\n    retryLimit?: number,\n    onceBlock?: OnceBlockable\n    oncePoll?: OncePollable\n};\n\nexport type FetchJsonResponse = {\n    statusCode: number;\n    headers: { [ header: string ]: string };\n};\n\n\ntype Header = { key: string, value: string };\n\nfunction unpercent(value: string): Uint8Array {\n    return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\n\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nexport function _fetchData<T = Uint8Array>(connection: string | ConnectionInfo, body?: Uint8Array, processFunc?: (value: Uint8Array, response: FetchJsonResponse) => T): Promise<T> {\n\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof(connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit: 12;\n    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0),\n        \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n\n    const throttleCallback = ((typeof(connection) === \"object\") ? connection.throttleCallback: null);\n    const throttleSlotInterval = ((typeof(connection) === \"object\" && typeof(connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval: 100);\n    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0),\n        \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n\n    const errorPassThrough = ((typeof(connection) === \"object\") ? !!(connection.errorPassThrough): false);\n\n    const headers: { [key: string]: Header } = { };\n\n    let url: string = null;\n\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options: Options = {\n        method: \"GET\",\n    };\n\n    let allow304 = false;\n\n    let timeout = 2 * 60 * 1000;\n\n    if (typeof(connection) === \"string\") {\n        url = connection;\n\n    } else if (typeof(connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n\n        url = connection.url;\n\n        if (typeof(connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n\n        options.allowGzip = !!connection.allowGzip;\n\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\n                    \"basic authentication requires a secure https url\",\n                    Logger.errors.INVALID_ARGUMENT,\n                    { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" }\n                );\n            }\n\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + base64Encode(toUtf8Bytes(authorization))\n            };\n        }\n\n        if (connection.skipFetchSetup != null) {\n            options.skipFetchSetup = !!connection.skipFetchSetup;\n        }\n\n        if (connection.fetchOptions != null) {\n            options.fetchOptions = shallowCopy(connection.fetchOptions);\n        }\n    }\n\n    const reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData): null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": (dataMatch[1] || \"text/plain\")},\n                body: (dataMatch[2] ? base64Decode(dataMatch[3]): unpercent(dataMatch[3]))\n            };\n\n            let result: T = <T><unknown>response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(<T><unknown>result);\n\n        } catch (error) {\n            logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n\n    const flatHeaders: { [ key: string ]: string } = { };\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n\n    const runningTimeout = (function() {\n        let timer: NodeJS.Timer = null;\n        const promise: Promise<never> = new Promise(function(resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) { return; }\n                    timer = null;\n\n                    reject(logger.makeError(\"timeout\", Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n\n        const cancel = function() {\n            if (timer == null) { return; }\n            clearTimeout(timer);\n            timer = null;\n        }\n\n        return { promise, cancel };\n    })();\n\n    const runningFetch = (async function() {\n\n        for (let attempt = 0; attempt < attemptLimit; attempt++) {\n            let response: GetUrlResponse = null;\n\n            try {\n                response = await getUrl(url, options);\n\n                if (attempt < attemptLimit) {\n                    if (response.statusCode === 301 || response.statusCode === 302) {\n                        // Redirection; for now we only support absolute locataions\n                        const location = response.headers.location || \"\";\n                        if (options.method === \"GET\" && location.match(/^https:/)) {\n                            url = response.headers.location;\n                            continue;\n                        }\n\n                    } else if (response.statusCode === 429) {\n                        // Exponential back-off throttling\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            let stall = 0;\n\n                            const retryAfter = response.headers[\"retry-after\"];\n                            if (typeof(retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                stall = parseInt(retryAfter) * 1000;\n                            } else {\n                                stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            }\n\n                            //console.log(\"Stalling 429\");\n                            await staller(stall);\n                            continue;\n                        }\n                    }\n                }\n\n            } catch (error) {\n                response = (<any>error).response;\n                if (response == null) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"missing response\", Logger.errors.SERVER_ERROR, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        serverError: error,\n                        url: url\n                    });\n                }\n            }\n\n\n            let body = response.body;\n\n            if (allow304 && response.statusCode === 304) {\n                body = null;\n            } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {\n                runningTimeout.cancel();\n                logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n                    status: response.statusCode,\n                    headers: response.headers,\n                    body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                    requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                    requestMethod: options.method,\n                    url: url\n                });\n            }\n\n            if (processFunc) {\n                try {\n                    const result = await processFunc(body, response);\n                    runningTimeout.cancel();\n                    return result;\n\n                } catch (error) {\n                    // Allow the processFunc to trigger a throttle\n                    if (error.throttleRetry && attempt < attemptLimit) {\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            //console.log(\"Stalling callback\");\n                            await staller(timeout);\n                            continue;\n                        }\n                    }\n\n                    runningTimeout.cancel();\n                    logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                        error: error,\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n            }\n\n            runningTimeout.cancel();\n\n            // If we had a processFunc, it either returned a T or threw above.\n            // The \"body\" is now a Uint8Array.\n            return <T>(<unknown>body);\n        }\n\n        return logger.throwError(\"failed response\", Logger.errors.SERVER_ERROR, {\n            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n            requestMethod: options.method,\n            url: url\n        });\n    })();\n\n    return Promise.race([ runningTimeout.promise, runningFetch ]);\n}\n\nexport function fetchJson(connection: string | ConnectionInfo, json?: string, processFunc?: (value: any, response: FetchJsonResponse) => any): Promise<any> {\n    let processJsonFunc = (value: Uint8Array, response: FetchJsonResponse) => {\n        let result: any = null;\n        if (value != null) {\n            try {\n                result = JSON.parse(toUtf8String(value));\n            } catch (error) {\n                logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n\n        return result;\n    }\n\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body: Uint8Array = null;\n    if (json != null) {\n        body = toUtf8Bytes(json);\n\n        // Create a connection with the content-type set for JSON\n        const updated: ConnectionInfo = (typeof(connection) === \"string\") ? ({ url: connection }): shallowCopy(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = shallowCopy(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        } else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n\n    return _fetchData<any>(connection, body, processJsonFunc);\n}\n\nexport function poll<T>(func: () => Promise<T>, options?: PollOptions): Promise<T> {\n    if (!options) { options = {}; }\n    options = shallowCopy(options);\n    if (options.floor == null) { options.floor = 0; }\n    if (options.ceiling == null) { options.ceiling = 10000; }\n    if (options.interval == null) { options.interval = 250; }\n\n    return new Promise(function(resolve, reject) {\n\n        let timer: NodeJS.Timer = null;\n        let done: boolean = false;\n\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = (): boolean => {\n            if (done) { return false; }\n            done = true;\n            if (timer) { clearTimeout(timer); }\n            return true;\n        };\n\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) { reject(new Error(\"timeout\")); }\n            }, options.timeout)\n        }\n\n        const retryLimit = options.retryLimit;\n\n        let attempt = 0;\n        function check() {\n            return func().then(function(result) {\n\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) { resolve(result); }\n\n                } else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n\n                } else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n\n                // Otherwise, exponential back-off (up to 10s) our next request\n                } else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) { reject(new Error(\"retry limit reached\")); }\n                        return;\n                    }\n\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) { timeout = options.floor; }\n                    if (timeout > options.ceiling) { timeout = options.ceiling; }\n\n                    setTimeout(check, timeout);\n                }\n\n                return null;\n            }, function(error) {\n                if (cancel()) { reject(error); }\n            });\n        }\n        check();\n    });\n}\n\n","export const version = \"web/5.7.1\";\n","import { JsonRpcRequest, JsonRpcResponse } from './internal-types';\n\n/** Maximum size of a batch on the rpc provider. */\nconst DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\n\n/** Timeout interval before the pending batch is sent. */\nconst DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\n\n/**\n * Internal class to enqueue requests and automatically send/process batches.\n *\n * The underlying batching mechanism is loosely based on ethers.js's\n * `JsonRpcBatchProvider`.\n *\n * @internal\n */\nexport class RequestBatcher {\n  /** Timeout timer that periodically sends the pending batch. */\n  private pendingBatchTimer: NodeJS.Timer | undefined;\n\n  /**\n   * Array of enqueued requests along with the constructed promise handlers for\n   * each request.\n   */\n  private pendingBatch: Array<BatchRequest> = [];\n\n  constructor(\n    private readonly sendBatchFn: SendBatchFn,\n    private readonly maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE\n  ) {}\n\n  /**\n   * Enqueues the provided request. The batch is immediately sent if the maximum\n   * batch size is reached. Otherwise, the request is enqueued onto a batch that\n   * is sent after 10ms.\n   *\n   * Returns a promise that resolves with the result of the request.\n   */\n  async enqueueRequest(request: JsonRpcRequest): Promise<any> {\n    const inflightRequest: BatchRequest = {\n      request,\n      resolve: undefined,\n      reject: undefined\n    };\n\n    const promise = new Promise((resolve, reject) => {\n      inflightRequest.resolve = resolve;\n      inflightRequest.reject = reject;\n    });\n\n    this.pendingBatch.push(inflightRequest);\n\n    if (this.pendingBatch.length === this.maxBatchSize) {\n      // Send batch immediately if we are at the maximum batch size.\n      void this.sendBatchRequest();\n    } else if (!this.pendingBatchTimer) {\n      // Schedule batch for next event loop + short duration\n      this.pendingBatchTimer = setTimeout(\n        () => this.sendBatchRequest(),\n        DEFAULT_REQUEST_BATCH_DELAY_MS\n      );\n    }\n\n    return promise;\n  }\n\n  /**\n   * Sends the currently queued batches and resets the batch and timer. Processes\n   * the batched response results back to the original promises.\n   */\n  private async sendBatchRequest(): Promise<void> {\n    // Get the current batch and clear it, so new requests\n    // go into the next batch\n    const batch = this.pendingBatch;\n    this.pendingBatch = [];\n    if (this.pendingBatchTimer) {\n      clearTimeout(this.pendingBatchTimer);\n      this.pendingBatchTimer = undefined;\n    }\n\n    // Get the request as an array of requests\n    const request = batch.map(inflight => inflight.request);\n\n    return this.sendBatchFn(request).then(\n      result => {\n        // For each result, feed it to the correct Promise, depending\n        // on whether it was a success or error\n        batch.forEach((inflightRequest, index) => {\n          const payload = result[index];\n          if (payload.error) {\n            const error = new Error(payload.error.message);\n            (error as any).code = payload.error.code;\n            (error as any).data = payload.error.data;\n            inflightRequest.reject!(error);\n          } else {\n            inflightRequest.resolve!(payload.result);\n          }\n        });\n      },\n      error => {\n        batch.forEach(inflightRequest => {\n          inflightRequest.reject!(error);\n        });\n      }\n    );\n  }\n}\n\n/** Function type to match the `fetchJson` function in ethers. */\ntype SendBatchFn = (reqs: JsonRpcRequest[]) => Promise<JsonRpcResponse[]>;\n\n/**\n * Internal interface to represent a request on a batch along with the promises to resolve it.\n */\ninterface BatchRequest {\n  request: JsonRpcRequest;\n  resolve?: (result: any) => void;\n  reject?: (error: Error) => void;\n}\n","import {\n  Network as NetworkFromEthers,\n  Networkish,\n  getNetwork as getNetworkFromEthers\n} from '@ethersproject/networks';\nimport { deepCopy } from '@ethersproject/properties';\nimport {\n  CommunityResourcable,\n  JsonRpcProvider\n} from '@ethersproject/providers';\nimport { ConnectionInfo, fetchJson } from '@ethersproject/web';\n\nimport { JsonRpcRequest, JsonRpcResponse } from '../internal/internal-types';\nimport { RequestBatcher } from '../internal/request-batcher';\nimport { Network } from '../types/types';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  DEFAULT_NETWORK,\n  EthersNetwork,\n  getAlchemyHttpUrl,\n  getAlchemyWsUrl\n} from '../util/const';\nimport { logWarn } from '../util/logger';\nimport { IS_BROWSER } from '../util/util';\nimport { VERSION } from '../version';\nimport { AlchemyConfig } from './alchemy-config';\n\n/**\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\n *\n * @public\n */\nexport class AlchemyProvider\n  extends JsonRpcProvider\n  implements CommunityResourcable\n{\n  readonly apiKey: string;\n  readonly maxRetries: number;\n  readonly batchRequests: boolean;\n\n  /**\n   * VISIBLE ONLY FOR TESTING\n   *@internal\n   */\n  readonly batcher: RequestBatcher;\n\n  /** @internal */\n  constructor(config: AlchemyConfig) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'http'\n    );\n\n    // If a hardcoded url was specified in the config, use that instead of the\n    // provided apiKey or network.\n    if (config.url !== undefined) {\n      connection.url = config.url;\n    }\n\n    connection.throttleLimit = config.maxRetries;\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(connection, ethersNetwork);\n\n    this.apiKey = config.apiKey;\n    this.maxRetries = config.maxRetries;\n    this.batchRequests = config.batchRequests;\n\n    // TODO: support individual headers when calling batch\n    const batcherConnection = {\n      ...this.connection,\n      headers: {\n        ...this.connection.headers,\n        'Alchemy-Ethers-Sdk-Method': 'batchSend'\n      }\n    };\n    const sendBatchFn = (\n      requests: JsonRpcRequest[]\n    ): Promise<JsonRpcResponse[]> => {\n      return fetchJson(batcherConnection, JSON.stringify(requests));\n    };\n    this.batcher = new RequestBatcher(sendBatchFn);\n\n    this.modifyFormatter();\n  }\n\n  /**\n   * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\n   * ethers.js. Returns the API key for an Alchemy provider.\n   *\n   * @internal\n   * @override\n   */\n  static getApiKey(apiKey: any): string {\n    if (apiKey == null) {\n      return DEFAULT_ALCHEMY_API_KEY;\n    }\n    if (apiKey && typeof apiKey !== 'string') {\n      throw new Error(\n        `Invalid apiKey '${apiKey}' provided. apiKey must be a string.`\n      );\n    }\n    return apiKey;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Converts the `Networkish` input to the network enum used by Alchemy.\n   *\n   * @internal\n   */\n  static getAlchemyNetwork(network?: Networkish): Network {\n    if (network === undefined) {\n      return DEFAULT_NETWORK;\n    }\n\n    if (typeof network === 'number') {\n      throw new Error(\n        `Invalid network '${network}' provided. Network must be a string.`\n      );\n    }\n\n    // Guaranteed that `typeof network === 'string`.\n    const isValidNetwork = Object.values(Network).includes(network as Network);\n    if (!isValidNetwork) {\n      throw new Error(\n        `Invalid network '${network}' provided. Network must be one of: ` +\n          `${Object.values(Network).join(', ')}.`\n      );\n    }\n    return network as Network;\n  }\n\n  /**\n   * Returns a {@link ConnectionInfo} object compatible with ethers that contains\n   * the correct URLs for Alchemy.\n   *\n   * @internal\n   */\n  static getAlchemyConnectionInfo(\n    network: Network,\n    apiKey: string,\n    type: 'wss' | 'http'\n  ): ConnectionInfo {\n    const url =\n      type === 'http'\n        ? getAlchemyHttpUrl(network, apiKey)\n        : getAlchemyWsUrl(network, apiKey);\n    return {\n      headers: IS_BROWSER\n        ? {\n            'Alchemy-Ethers-Sdk-Version': VERSION\n          }\n        : {\n            'Alchemy-Ethers-Sdk-Version': VERSION,\n            'Accept-Encoding': 'gzip'\n          },\n      allowGzip: true,\n      url\n    };\n  }\n\n  /**\n   * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\n   * method is called when calling methods on the parent class `BaseProvider`.\n   *\n   * @override\n   */\n  async detectNetwork(): Promise<NetworkFromEthers> {\n    let network = this.network;\n    if (network == null) {\n      network = await super.detectNetwork();\n\n      if (!network) {\n        throw new Error('No network detected');\n      }\n    }\n    return network;\n  }\n\n  _startPending(): void {\n    logWarn('WARNING: Alchemy Provider does not support pending filters');\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * Overrides the base {@link JsonRpcProvider.send} method to implement custom\n   * logic for sending requests to Alchemy.\n   *\n   * @param method The method name to use for the request.\n   * @param params The parameters to use for the request.\n   * @override\n   * @public\n   */\n  // TODO: Add headers for `perform()` override.\n  send(method: string, params: Array<any>): Promise<any> {\n    return this._send(method, params, 'send');\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `JsonRpcProvider.send()`.\n   *\n   * This method is copied over directly in order to implement custom headers\n   *\n   * @internal\n   */\n  _send(\n    method: string,\n    params: Array<any>,\n    methodName: string,\n    forceBatch = false\n  ): Promise<any> {\n    const request = {\n      method,\n      params,\n      id: this._nextId++,\n      jsonrpc: '2.0'\n    };\n\n    // START MODIFIED CODE\n    const connection = { ...this.connection };\n    connection.headers!['Alchemy-Ethers-Sdk-Method'] = methodName;\n\n    if (this.batchRequests || forceBatch) {\n      return this.batcher.enqueueRequest(request as JsonRpcRequest);\n    }\n    // END MODIFIED CODE\n\n    this.emit('debug', {\n      action: 'request',\n      request: deepCopy(request),\n      provider: this\n    });\n\n    // We can expand this in the future to any call, but for now these\n    // are the biggest wins and do not require any serializing parameters.\n    const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\n    if (cache && this._cache[method]) {\n      return this._cache[method];\n    }\n\n    const result = fetchJson(\n      this.connection,\n      JSON.stringify(request),\n      getResult\n    ).then(\n      result => {\n        this.emit('debug', {\n          action: 'response',\n          request,\n          response: result,\n          provider: this\n        });\n\n        return result;\n      },\n      error => {\n        this.emit('debug', {\n          action: 'response',\n          error,\n          request,\n          provider: this\n        });\n\n        throw error;\n      }\n    );\n\n    // Cache the fetch, but clear it on the next event loop\n    if (cache) {\n      this._cache[method] = result;\n      setTimeout(() => {\n        // @ts-ignore - This is done by ethers.\n        this._cache[method] = null;\n      }, 0);\n    }\n\n    return result;\n  }\n\n  /**\n   * Overrides the base `Formatter` class inherited from ethers to support\n   * returning custom fields in Ethers response types.\n   *\n   * For context, ethers has a `Formatter` class that is used to format the\n   * response from a JSON-RPC request. Any fields that are not defined in the\n   * `Formatter` class are removed from the returned response. By modifying the\n   * `Formatter` class in this method, we can add support for fields that are\n   * not defined in ethers.\n   */\n  private modifyFormatter(): void {\n    this.formatter.formats['receiptLog']['removed'] = val => {\n      if (typeof val === 'boolean') {\n        return val;\n      }\n      return undefined;\n    };\n  }\n}\n\n/**\n * DO NOT MODIFY.\n *\n * Original code copied over from ether.js's\n * `@ethersproject/web/src.ts/index.ts`. Used to support\n * {@link AlchemyProvider._send}, which is also copied over.\n */\nfunction getResult(payload: {\n  error?: { code?: number; data?: any; message?: string };\n  result?: any;\n}): any {\n  if (payload.error) {\n    const error: any = new Error(payload.error.message);\n    error.code = payload.error.code;\n    error.data = payload.error.data;\n    throw error;\n  }\n\n  return payload.result;\n}\n","'use strict'\nvar ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'\n\n// pre-compute lookup table\nvar ALPHABET_MAP = {}\nfor (var z = 0; z < ALPHABET.length; z++) {\n  var x = ALPHABET.charAt(z)\n\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep (pre) {\n  var b = pre >> 25\n  return ((pre & 0x1FFFFFF) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n}\n\nfunction prefixChk (prefix) {\n  var chk = 1\n  for (var i = 0; i < prefix.length; ++i) {\n    var c = prefix.charCodeAt(i)\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'\n\n    chk = polymodStep(chk) ^ (c >> 5)\n  }\n  chk = polymodStep(chk)\n\n  for (i = 0; i < prefix.length; ++i) {\n    var v = prefix.charCodeAt(i)\n    chk = polymodStep(chk) ^ (v & 0x1f)\n  }\n  return chk\n}\n\nfunction encode (prefix, words, LIMIT) {\n  LIMIT = LIMIT || 90\n  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')\n\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') throw new Error(chk)\n\n  var result = prefix + '1'\n  for (var i = 0; i < words.length; ++i) {\n    var x = words[i]\n    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n    chk = polymodStep(chk) ^ x\n    result += ALPHABET.charAt(x)\n  }\n\n  for (i = 0; i < 6; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk ^= 1\n\n  for (i = 0; i < 6; ++i) {\n    var v = (chk >> ((5 - i) * 5)) & 0x1f\n    result += ALPHABET.charAt(v)\n  }\n\n  return result\n}\n\nfunction __decode (str, LIMIT) {\n  LIMIT = LIMIT || 90\n  if (str.length < 8) return str + ' too short'\n  if (str.length > LIMIT) return 'Exceeds length limit'\n\n  // don't allow mixed case\n  var lowered = str.toLowerCase()\n  var uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str\n  str = lowered\n\n  var split = str.lastIndexOf('1')\n  if (split === -1) return 'No separator character for ' + str\n  if (split === 0) return 'Missing prefix for ' + str\n\n  var prefix = str.slice(0, split)\n  var wordChars = str.slice(split + 1)\n  if (wordChars.length < 6) return 'Data too short'\n\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') return chk\n\n  var words = []\n  for (var i = 0; i < wordChars.length; ++i) {\n    var c = wordChars.charAt(i)\n    var v = ALPHABET_MAP[c]\n    if (v === undefined) return 'Unknown character ' + c\n    chk = polymodStep(chk) ^ v\n\n    // not in the checksum?\n    if (i + 6 >= wordChars.length) continue\n    words.push(v)\n  }\n\n  if (chk !== 1) return 'Invalid checksum for ' + str\n  return { prefix: prefix, words: words }\n}\n\nfunction decodeUnsafe () {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n}\n\nfunction decode (str) {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n\n  throw new Error(res)\n}\n\nfunction convert (data, inBits, outBits, pad) {\n  var value = 0\n  var bits = 0\n  var maxV = (1 << outBits) - 1\n\n  var result = []\n  for (var i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding'\n    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'\n  }\n\n  return result\n}\n\nfunction toWordsUnsafe (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n}\n\nfunction toWords (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nfunction fromWordsUnsafe (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n}\n\nfunction fromWords (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nmodule.exports = {\n  decodeUnsafe: decodeUnsafe,\n  decode: decode,\n  encode: encode,\n  toWordsUnsafe: toWordsUnsafe,\n  toWords: toWords,\n  fromWordsUnsafe: fromWordsUnsafe,\n  fromWords: fromWords\n}\n"],"names":["decode","textData","atob","data","i","length","push","charCodeAt","arrayify","encode","String","fromCharCode","btoa","logger","Logger","ethDefaultProvider","network","func","providers","options","providerList","InfuraProvider","infura","error","EtherscanProvider","etherscan","AlchemyProvider","alchemy","PocketProvider","pocket","skip","provider","indexOf","name","CloudflareProvider","cloudflare","AnkrProvider","ankr","FallbackProvider","quorum","renetwork","etcDefaultProvider","url","JsonRpcProvider","homestead","chainId","ensAddress","_defaultProvider","ropsten","classicMordor","networks","unspecified","mainnet","morden","testnet","rinkeby","kovan","goerli","kintsugi","sepolia","classic","classicMorden","classicTestnet","classicKotti","xdai","matic","maticmum","optimism","arbitrum","bnb","bnbt","getNetwork","standard","throwArgumentError","defaultProvider","value","version","flat","array","depth","result","forEach","flatDeep","arr","call","val","Array","isArray","read_compressed_payload","bytes","v","pos","read_payload","u16","symbol_count","total","acc","pos_payload","read_width","read_buffer","read_bit","FULL","Math","pow","HALF","QRTR","MASK","register","symbols","low","range","floor","start","end","mid","a","b","offset","map","x","decode_arithmetic","signed","read_ascending","n","next","read_deltas","read_member_array","lookup","vX","vN","read_counts","j","read_transposed","w","m","fill","undefined","read_linear_table","dx","dy","read_zero_terminated_array","ys","slice","_","j_dy","y","read_replacement_table","r","VALID","Set","IGNORED","MAPPED","ret","fromEntries","read_mapped_map","EMOJI_ROOT","sorted","sort","read","branches","keys","set","node","size","temp","valid","fe0f","save","check","read_emoji_trie","HYPHEN","UNDERSCORE","explode_cp","toUtf8CodePoints","filter_fe0f","cps","filter","cp","ens_normalize_post_check","label","split","lastIndexOf","Error","every","err","concat","message","ens_normalize","emoji_filter","input","reverse","output","emoji","consume_emoji_reversed","pop","has","toString","toUpperCase","s","fromCodePoint","normalize","eaten","saved","stack","_a","find","splice","Zeros","Uint8Array","checkComponent","comp","ensNameSplit","toUtf8Bytes","comps","last","namehash","keccak256","hexlify","Formatter","constructor","this","formats","getDefaultFormats","address","bind","bigNumber","blockTag","hash","hex","number","type","transaction","accessList","allowNull","blockHash","blockNumber","transactionIndex","confirmations","from","gasPrice","maxPriorityFeePerGas","maxFeePerGas","gasLimit","to","nonce","uint256","creates","raw","transactionRequest","receiptLog","transactionHash","topics","arrayOf","logIndex","receipt","contractAddress","root","gasUsed","logsBloom","logs","cumulativeGasUsed","effectiveGasPrice","status","block","parentHash","timestamp","difficulty","miner","extraData","transactions","baseFeePerGas","blockWithTransactions","shallowCopy","transactionResponse","fromBlock","toBlock","filterLog","removed","boolean","allowFalsish","accessListify","BigNumber","toNumber","toLowerCase","strict","substring","isHexString","getAddress","callAddress","hexDataSlice","getContractAddress","hexValue","hexDataLength","hexZeroPad","_block","format","author","_difficulty","gas","isZero","networkId","parseInt","replace","parseTransaction","byzantium","object","key","checkKey","checkValue","nullValue","replaceValue","checkTopic","topic","serializeTopics","unique","Object","join","getEventTag","eventName","ForkEvent","isForkEvent","warn","getTime","Date","stall","duration","Promise","resolve","setTimeout","PollableEvents","Event","tag","listener","once","defineReadOnly","_lastBlockNumber","_inflight","event","pollable","coinInfos","symbol","p2pkh","p2sh","prefix","ilk","bytes32ify","toHexString","base58Encode","Base58","sha256","matcherIpfs","RegExp","matchers","_parseString","toUtf8String","_parseBytes","getIpfsLink","link","match","numPad","padded","bytesPad","ceil","encodeBytes","datas","byteCount","hexConcat","Resolver","resolvedAddress","formatter","supportsWildcard","_supportsEip2544","then","eq","catch","code","errors","CALL_EXCEPTION","_fetch","selector","parameters","tx","ccipReadEnabled","parseBytes","throwError","_fetchBytes","_getAddress","coinType","hexBytes","coinInfo","UNSUPPORTED_OPERATION","operation","words","bech32","unshift","getAvatar","linkage","content","avatar","getText","scheme","owner","_resolvedAddress","addr","tokenId","tokenOwner","balance","metadataUrl","metadata","fetchJson","JSON","stringify","imageUrl","image","getContentHash","ipfs","ipns","swarm","skynet","urlSafe","base64Encode","keyBytes","defaultFormatter","nextPollId","BaseProvider","Provider","super","_events","_emitted","disableCcipRead","getFormatter","anyNetwork","detectNetwork","_networkPromise","_ready","knownNetwork","getStatic","emit","_maxInternalBlockNumber","_maxFilterBlockRange","_pollingInterval","_fastQueryDate","_network","UNKNOWN_ERROR","ready","poll","NETWORK_ERROR","ccipReadFetch","calldata","urls","sender","errorMessages","href","json","errorPassThrough","response","statusCode","errorMessage","SERVER_ERROR","_getInternalBlockNumber","maxAge","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","resolveProperties","perform","networkError","_ref","_setFastBlockNumber","pollId","runners","pollingInterval","abs","makeError","previousBlockNumber","eventBlockNumber","runner","getTransactionReceipt","minFromBlock","getLogs","log","all","resetEventsBlock","polling","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_poller","setInterval","_bootstrapPoll","clearInterval","_getFastBlockNumber","now","getBlockNumber","waitForTransaction","timeout","_waitForTransaction","replaceable","reject","cancelFuncs","done","alreadyDone","minedHandler","on","removeListener","lastBlockNumber","startBlock","scannedBlock","replaceHandler","__awaiter","getTransactionCount","mined","getTransaction","getBlockWithTransactions","ti","reason","TRANSACTION_REPLACED","cancelled","replacement","_wrapTransaction","timer","TIMEOUT","unref","clearTimeout","getGasPrice","method","getBalance","addressOrName","params","_getBlockTag","getCode","getStorageAt","position","p","expectedHash","returnedHash","wait","confirms","sendTransaction","signedTransaction","hexTx","t","_getTransactionRequest","values","_getFilter","_call","attempt","redirects","txSender","signature","urlsOffset","urlsLength","urlsData","u","callbackSelector","ccipResult","resolved","estimateGas","resolveName","_getBlock","blockHashOrBlockTag","includeTransactions","blockWithTxs","oncePoll","getBlock","getEtherPrice","getResolver","currentName","_getResolver","resolver","addrData","lookupAddress","resolverAddr","nameOrAddress","resolverAddress","NOT_IMPLEMENTED","_startEvent","e","_stopEvent","_addEventListener","_len","arguments","args","_key","stopped","eventTag","apply","listenerCount","listeners","off","removeAllListeners","found","errorGas","spelunk","requireData","parse","checkError","body","UNPREDICTABLE_GAS_LIMIT","responseText","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","getResult","payload","getLowerCase","_constructorGuard","JsonRpcSigner","Signer","constructorGuard","addressOrIndex","connect","connectUnchecked","UncheckedJsonRpcSigner","_address","_index","send","accounts","sendUncheckedTransaction","fromAddress","estimate","hexlifyTransaction","ACTION_REJECTED","action","signTransaction","signMessage","messageData","_legacySignMessage","_signTypedData","domain","types","populated","_TypedDataEncoder","resolveNames","getPayload","unlock","password","allowedTransactionKeys","networkOrReady","freeze","_nextId","_cache","_eventLoopCache","defaultUrl","_uncachedDetectNetwork","serverError","getSigner","getUncheckedSigner","listAccounts","request","id","jsonrpc","deepCopy","cache","connection","prepareRequest","feeData","getFeeData","_startPending","_pendingFilter","self","pendingFilter","filterId","hashes","seq","allowExtra","allowed","checkProperties","getUrl","headers","skipFetchSetup","mode","credentials","redirect","referrer","fetchOptions","opts","fetch","arrayBuffer","get","statusMessage","statusText","staller","bodyify","isBytesLike","trim","processFunc","updated","k","attemptLimit","throttleLimit","assertArgument","throttleCallback","throttleSlotInterval","allow304","allowGzip","user","allowInsecureAuthentication","INVALID_ARGUMENT","argument","authorization","reData","dataMatch","base64Decode","requestBody","requestMethod","flatHeaders","header","runningTimeout","promise","cancel","runningFetch","location","tryAgain","retryAfter","random","throttleRetry","race","_fetchData","processJsonFunc","ceiling","interval","retryLimit","onceBlock","RequestBatcher","sendBatchFn","maxBatchSize","pendingBatch","enqueueRequest","inflightRequest","sendBatchRequest","pendingBatchTimer","batch","inflight","index","config","apiKey","getApiKey","alchemyNetwork","getAlchemyNetwork","getAlchemyConnectionInfo","maxRetries","EthersNetwork","batchRequests","batcherConnection","assign","batcher","requests","modifyFormatter","DEFAULT_ALCHEMY_API_KEY","CustomNetworks","DEFAULT_NETWORK","Network","includes","getAlchemyHttpUrl","getAlchemyWsUrl","IS_BROWSER","VERSION","_super","logWarn","isCommunityResource","_send","methodName","forceBatch","ALPHABET","ALPHABET_MAP","z","charAt","TypeError","polymodStep","pre","prefixChk","chk","c","__decode","str","LIMIT","lowered","uppered","wordChars","convert","inBits","outBits","pad","bits","maxV","module","exports","decodeUnsafe","res","toWordsUnsafe","toWords","fromWordsUnsafe","fromWords"],"sourceRoot":""}